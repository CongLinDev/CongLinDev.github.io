<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单博客系统(Web)]]></title>
    <url>%2F2019%2F03%2F03%2F%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F-Web%2F</url>
    <content type="text"><![CDATA[Serendipity简介Serendipity （意为发现美好）是一个简单的微型博客项目，由 Spring Boot(Maven) 构建，其中使用了 Spring MVC Spring Security Spring Data Jpa , 数据库使用了 MySQL。 项目功能包含： 用户注册 用户登陆 发布信息 删除信息 注：该项目中，用户称为 Serendipper 信息称为 Serendimsg 。 源码源码已经托管在Github，戳我 查看源码。 详细介绍实体用户（Serendipper）在包含了一些必要属性的前提下，使用 @OneToMany 关联到 信息（Serendimsg）。 信息（Serendimsg）在包含了一些必要属性的前提下，使用 @CreatedBy 关联到 用户（Serendipper），以及 @CreatedDate 确定发送时间。 Controller调用 Service 提供的接口实现功能。 由于时间紧迫，没有编写 RESTful 风格的 Controller。而是使用传统的 Thymeleaf 模板引擎进行渲染。 Service接口 SerendipperService 和 SerendimsgService 为 Controller 层服务。 SerendipperServiceImpl 和 SerendimsgServiceImpl 实现了接口。 DAO接口 SerendipperRepository 和 SerendimsgRepository 继承 JpaRepository 为 Service 层服务。 因此不用特意实现这两个接口，只需要根据 Spring Data 的规定编写接口即可。 SecuritySecurity 使用Spring Security 控制。具体设置位于类 conglin.serendipity.config.WebSecurityConfig 中。 下载1git clone git@github.com:CongLinDev/Serendipity.git]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串匹配的三个算法]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%9A%84%E4%B8%89%E4%B8%AA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串匹配的意思是给一个字符串集合，和另一个字符串集合，看这两个集合交集是多少。 若是都只有一个字符串，那么就看其中一个是否包含另外一个； 若是父串集合（比较长的，被当做模板）的有多个，子串（拿去匹配的）只有一个，就是问这个子串是否存在于父串之中； 若是子串父串集合都有多个，那么就是问交集了。 KMP算法KMP算法是用来处理一对一的匹配的。 朴素的匹配算法，或者说暴力匹配法，就是将两个字符串从头比到尾，若是有一个不同，那么从下一位再开始比。这样太慢了。所以KMP算法的思想是，对匹配串本身先做一个处理，得到一个next数组。这个数组是做什么用的呢？next [j] = k，代表j之前的字符串中有最大长度为k 的相同前缀后缀。记录这个有什么用呢？对于ABCDABC这个串，如果我们匹配ABCDABTBCDABC这个长串，当匹配到第7个字符T的时候就不匹配了,我们就不用直接移到B开始再比一次，而是直接移到第5位来比较，岂不美哉？所以求出了next数组，KMP就完成了一大半。next数组也可以说是开始比较的位数。 计算next数组的方法是对于长度为n的匹配串，从0到n-1位依次求出前缀后缀最大匹配长度。 比如ABCDABD这个串: 如何去求next数组呢？k是匹配下标。这里没有从最后一位开始和第一位开始分别比较前缀后缀，而是利用了next[i-1]的结果。 123456789101112131415161718192021222324252627282930void getnext()//获取next数组&#123; int i,n,k; n=strlen(ptr); memset(next,0,sizeof(next)); k=0; for(i=1;i&lt;n;i++) &#123; while(k&gt;0 &amp;&amp; ptr[k]!=ptr[i]) k=next[k]; if(ptr[k]==ptr[i]) k++; next[i+1]=k; //next表示的是匹配长度 &#125;&#125; 这里是按照《算法导论》的代码来写的。算法导论算法循环是从1到n而不是从0到n-1，所以在下面匹配的时候需要j=next[j+1]。 1234567891011121314151617181920212223242526272829303132int kmp(char *a,char *b)//匹配ab两串，a为父串&#123; int i=0,j=0; int len1=strlen(a); int len2=strlen(b); getnext(); while(i&lt;len1&amp;&amp;j&lt;len2) &#123; if(j==0||a[i]==b[j]) &#123; i++;j++; &#125; else j=next[j+1];//到前一个匹配点 &#125; if(j&gt;=len2) return i-j; else return -1;&#125; 这里next数组的作用就显现出来了。最后返回的是i-j，也就是说，是从i位置前面的第j位开始的，也就是上面说的，next数组也可以说是开始比较的位数。也就是说，在父串的i位比的时候已经是在比子串的第j位了。 一个完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int N=100;char str[100],ptr[100];//父串str和子串ptrint next[100];string ans;void getnext()//获取next数组&#123; int i,n,k; n=strlen(ptr); memset(next,0,sizeof(next)); k=0; for(i=1;i&lt;n;i++) &#123; while(k&gt;0 &amp;&amp; ptr[k]!=ptr[i]) k=next[k]; if(ptr[k]==ptr[i]) k++; next[i+1]=k; //next表示的是匹配长度 &#125;&#125;int kmp(char *a,char *b)//匹配ab两串，a为父串&#123; int i=0,j=0; int len1=strlen(a); int len2=strlen(b); getnext(); while(i&lt;len1&amp;&amp;j&lt;len2) &#123; if(j==0||a[i]==b[j]) &#123; i++;j++; &#125; else j=next[j+1];//到前一个匹配点 &#125; if(j&gt;=len2) return i-j; else return -1;&#125;int main()&#123; while( scanf( "%s%s", str, ptr ) ) &#123; int ans = kmp(str,ptr); if(ans&gt;=0) printf( "%d\n", kmp( str,ptr )); else printf("Not find\n"); &#125; return 0;&#125; 字典树算法上面的KMP是一对一匹配的时候常用的算法。而字典树则是一对多的时候匹配常用算法。其含义是，把一系列的模板串放到一个树里面，然后每个节点存的是它自己的字符，从根节点开始往下遍历就可以得到一个个单词了。 我这里写的代码稍微和上面有一点区别，我的节点tnode里面没有存它本身的字符，而是存一个孩子数组。所以当数据量很大的时候还是需要做一些变通的，不可直接套用此代码。若是想以每个节点为一个node，那么要注意根节点是空的。 树的节点tnode，这里的next[i]存的是子节点指针。sum=0表示这个点不是重点。为n&gt;0表示有n个单词以此为终点。 123456789101112131415161718struct tnode&#123; int sum;//用来判断是否是终点的 tnode* next[26]; tnode()&#123; for(int i =0;i&lt;26;i++) next[i]=NULL; sum=0; &#125;&#125;; 插入函数： 假设字典树已经有了aer，现在插入abc,首先看a,不为空，那么直接跳到a节点里，看b，为空，那么新建，跳到b里，新建c，跳出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152tnode* newnode()&#123; tnode *p = new tnode; for(int i =0;i&lt;26;i++) p-&gt;next[i]=NULL; p-&gt;sum=0; return p;&#125;//插入函数void Insert(char *s)&#123; tnode *p = root; for(int i = 0 ; s[i] ; i++) &#123; int x = s[i] - 'a'; if(p-&gt;next[x]==NULL) &#123; tnode *nn=newnode(); for(int j=0;j&lt;26;j++) nn-&gt;next[j] = NULL; nn-&gt;sum = 0; p-&gt;next[x]=nn; &#125; p = p-&gt;next[x]; &#125; p-&gt;sum++;//这个单词终止啦&#125; 字符串比较：就是一个个字符去比呗…时间复杂度O(m)，m是匹配串长度。 1234567891011121314151617181920212223242526272829303132bool Compare(char *ch)&#123; tnode *p = root; int len = strlen(ch); for(int i = 0; i &lt; len; i++) &#123; int x = ch[i] - 'a'; p = p-&gt;next[x]; if(p==NULL) return false; if(i==len-1 &amp;&amp; p-&gt;sum&gt;0 )&#123; return true; &#125; &#125; return false;&#125; 给个完整的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include&lt;queue&gt;#include&lt;set&gt;#include&lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;/* trie字典树*/struct tnode&#123; int sum;//用来判断是否是终点的 tnode* next[26]; tnode()&#123; for(int i =0;i&lt;26;i++) next[i]=NULL; sum=0; &#125;&#125;;tnode *root; tnode* newnode()&#123; tnode *p = new tnode; for(int i =0;i&lt;26;i++) p-&gt;next[i]=NULL; p-&gt;sum=0; return p;&#125;//插入函数void Insert(char *s)&#123; tnode *p = root; for(int i = 0 ; s[i] ; i++) &#123; int x = s[i] - 'a'; if(p-&gt;next[x]==NULL) &#123; tnode *nn=newnode(); for(int j=0;j&lt;26;j++) nn-&gt;next[j] = NULL; nn-&gt;sum = 0; p-&gt;next[x]=nn; &#125; p = p-&gt;next[x]; &#125; p-&gt;sum++;//这个单词终止啦&#125;//匹配函数bool Compare(char *ch)&#123; tnode *p = root; int len = strlen(ch); for(int i = 0; i &lt; len; i++) &#123; int x = ch[i] - 'a'; p = p-&gt;next[x]; if(p==NULL) return false; if(i==len-1 &amp;&amp; p-&gt;sum&gt;0 )&#123; return true; &#125; &#125; return false;&#125;void DELETE(tnode * &amp;top)&#123; if(top==NULL) return; for(int i =0;i&lt;26;i++) DELETE(top-&gt;next[i]); delete top;&#125;int main()&#123; int n,m; cin&gt;&gt;n; char s[20]; root = newnode(); for(int i =0;i&lt;n;i++)&#123; scanf("%s",s); Insert(s); &#125; cin&gt;&gt;m; for(int i =0;i&lt;m;i++)&#123; scanf("%s",s); if(Compare(s)) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; DELETE(root); return 0;&#125; AC自动机字典树是一对多的匹配，那么AC自动机就是多对多的匹配了。意思是：给一个字典，再给一个m长的文本，问这个文本里出现了字典里的哪些字。 这个问题可以用n个单词的n次KMP算法来做(效率为O(n*m*单词平均长度))，也可以用1个字典树去匹配文本串的每个字母位置来做(效率为O(m*每次字典树遍历的平均深度))。上面两种解法效率都不高，如果用AC自动机来解决的话，效率将为线性O(m)时间复杂度。 AC自动机也运用了一点KMP算法的思想。简述为字典树+KMP也未为不可。 首先讲一下acnode的结构： 与字典树相比，就多了个fail指针对吧，这个就相当于KMP算法里的next数组。只不过它存的是失配后跳转的位置，而不是跳转之后再向前跳了多少罢了。 12345678910111213141516171819202122struct acnode&#123; int sum; acnode* next[26]; acnode* fail; acnode()&#123; for(int i =0;i&lt;26;i++) next[i]=NULL; fail= NULL; sum=0; &#125;&#125;; 插入什么的我就不说了，记得把fail置为空即可。 这里说一下fail指针的获取。fail指针是通过BFS来求的。 看这么一张图 图中数字我们不用管它，绿色代表是终点，虚线就是fail指针了。我们可以看到91 E节点的fail指针是指向76 E 的，也就是说执行到这里如果无法继续匹配就会跳到76 E那个节点继续往后匹配。我们可以看到它们前面都是H，也就是说fail指针指向的是父节点相同的同值节点（根节点视为与任何节点相同）。我们要算的是在一个长文本里面有多少个出现的单词，这个fail指针就是为了快速匹配而诞生的。若文本里出现了HISHERS,我们首先匹配了HIS,有通过fail指针跳到85 S从而匹配SHE，再匹配HERS。fail指针跳到哪里就代表这一点之前的内容已经被匹配了。这样就避免了再从头重复判断的过程。 在函数里，当前节点的fail指针也会去更新此节点的孩子的fail指针，因为父节点相同啊，而且因为它是此节点的fail指针，这两个节点的父节点也相同啊~所以一路相同过来，就保证fail指向的位置前缀是相同的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void getfail()&#123; queue&lt;acnode*&gt; q; for(int i = 0 ; i &lt; 26 ; i ++ ) &#123; if(root-&gt;next[i]!=NULL)&#123; root-&gt;next[i]-&gt;fail = root; q.push(root-&gt;next[i]); &#125; &#125; while(!q.empty())&#123; acnode* tem = q.front(); q.pop(); for(int i = 0;i&lt;26;i++)&#123; if(tem-&gt;next[i]!=NULL) &#123; acnode *p; p = tem-&gt;fail; while(p!=NULL)&#123; if(p-&gt;next[i]!=NULL)&#123; tem-&gt;next[i]-&gt;fail = p-&gt;next[i]; break; &#125; p=p-&gt;fail; &#125; if(p==NULL) tem-&gt;next[i]-&gt;fail = root; q.push(tem-&gt;next[i]); &#125; &#125; &#125;&#125; 给个完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280#include&lt;queue&gt;#include&lt;set&gt;#include&lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;/* ac自动机*/struct acnode&#123; int sum; acnode* next[26]; acnode* fail; acnode()&#123; for(int i =0;i&lt;26;i++) next[i]=NULL; fail= NULL; sum=0; &#125;&#125;;acnode *root;int cnt;acnode* newnode()&#123; acnode *p = new acnode; for(int i =0;i&lt;26;i++) p-&gt;next[i]=NULL; p-&gt;fail = NULL; p-&gt;sum=0; return p;&#125;//插入函数void Insert(char *s)&#123; acnode *p = root; for(int i = 0; s[i]; i++) &#123; int x = s[i] - 'a'; if(p-&gt;next[x]==NULL) &#123; acnode *nn=newnode(); for(int j=0;j&lt;26;j++) nn-&gt;next[j] = NULL; nn-&gt;sum = 0; nn-&gt;fail = NULL; p-&gt;next[x]=nn; &#125; p = p-&gt;next[x]; &#125; p-&gt;sum++;&#125;//获取fail指针，在插入结束之后使用void getfail()&#123; queue&lt;acnode*&gt; q; for(int i = 0 ; i &lt; 26 ; i ++ ) &#123; if(root-&gt;next[i]!=NULL)&#123; root-&gt;next[i]-&gt;fail = root; q.push(root-&gt;next[i]); &#125; &#125; while(!q.empty())&#123; acnode* tem = q.front(); q.pop(); for(int i = 0;i&lt;26;i++)&#123; if(tem-&gt;next[i]!=NULL) &#123; acnode *p; if(tem == root)&#123; tem-&gt;next[i]-&gt;fail = root; &#125; else &#123; p = tem-&gt;fail; while(p!=NULL)&#123; if(p-&gt;next[i]!=NULL)&#123; tem-&gt;next[i]-&gt;fail = p-&gt;next[i]; break; &#125; p=p-&gt;fail; &#125; if(p==NULL) tem-&gt;next[i]-&gt;fail = root; &#125; q.push(tem-&gt;next[i]); &#125; &#125; &#125;&#125;//匹配函数void ac_automation(char *ch)&#123; acnode *p = root; int len = strlen(ch); for(int i = 0; i &lt; len; i++) &#123; int x = ch[i] - 'a'; while(p-&gt;next[x]==NULL &amp;&amp; p != root)//没匹配到，那么就找fail指针。 p = p-&gt;fail; p = p-&gt;next[x]; if(!p) p = root; acnode *temp = p; while(temp != root) &#123; if(temp-&gt;sum &gt;= 0) /* 在这里已经匹配成功了，执行想执行的操作即可，怎么改看题目需求+ */ &#123; cnt += temp-&gt;sum; temp-&gt;sum = -1; &#125; else break; temp = temp-&gt;fail; &#125; &#125;&#125;int main()&#123; cnt = 0; int n; cin&gt;&gt;n; char c[101]; root = newnode(); for(int i = 0 ;i &lt; n;i++)&#123; scanf("%s",c); Insert(c); &#125; getfail(); int m ; cin&gt;&gt; m; for(int i = 0;i&lt;m;i++)&#123; scanf("%s",c); ac_automation(c); &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞机大战游戏设计]]></title>
    <url>%2F2019%2F01%2F01%2F%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[本项目基于 Python3 进行开发，使用了 pygame 模块。 开发这个项目的目的不是为了做游戏，而是熟悉 设计模式 。 源代码源码已经托管在Github，戳我 查看源码。你也可以通过使用命令 git clone git@github.com:CongLinDev/AirplaneWarGame.git 直接下载源码查看。 类图类图如下： 设计模式该项目用到了多种设计模式，但由于Python是动态语言，所以一些可以用到的设计模式没有涉及。 静态工厂方法对于 Plane 和 Bullet 的创建均是使用了静态工厂创建。 生成器游戏中的 Level 实质上是一个生成器，根据 Level 的不同，生成的 EnemyPlane 数量不同，其组装的 EnemyPlaneGroup 也不同。 桥接游戏中的 Listener 起到了桥接的作用，监听按下不同 Button 对象。 享元工厂这里设计的享元的作用是一次加载所需的资源如图片、音乐等。不同常规的是，这里的享元工厂并没有工厂，笔者把它设计成 单件模式 的效果。 单件模式这里的享元使用Python的type方法进行创建其元类，只需要使用一个语句 __metaclass__ = metaflyweight 即可将类变成单件。函数 metaflyweight 如下： 123456789101112131415#纯函数式使用元类#type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)metaflyweight = lambda name, parents, attrs: type( name, parents, dict(attrs.items() + [ ('__instances', dict()), ('__new__', classmethod( lambda cls, *args, **kargs: cls.__instances.setdefault(#setdefault() 键如果不在字典中，会更新字典 tuple(args), super(type(cls), cls).__new__(*args, **kargs)) ) ) ]) ) 命令模式游戏中玩家飞机的子弹由玩家飞机通过一个 Command 的子类进行通知发射，其作用是为了使发射子弹与飞机移动进行 时间 上的解耦，有利于以后的扩展。 Demo]]></content>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓取简单的Pcap文件并读出信息]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%8A%93%E5%8F%96%E7%AE%80%E5%8D%95%E7%9A%84Pcap%E6%96%87%E4%BB%B6%E5%B9%B6%E8%AF%BB%E5%87%BA%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[以下开发均基于Linux平台，以Ubuntu为例进行讲解，具体源码移步这里。 抓取Pcap文件笔者使用libpcap库（libpcap是unix/linux平台下的网络数据包捕获函数包）进行抓包。 安装libpcap库 Libpcap下载。 解压下载的压缩包 tar -zxvf filename.tar.gz （filename是下载的文件名） 配置生成makefile文件。进入解压的文件夹，执行 ./configure。这里可能会提示缺少flex，使用sudo apt-get install flex即可。 执行make。这里可能会提示缺少yacc，使用sudo apt-get install yacc即可。 执行sudo make install。 使用库函数抓包 pcap_lookupdev()：函数用于查找网络设备，返回可被 pcap_open_live() 函数调用的网络设备名指针。 pcap_lookupnet()：函数获得指定网络设备的网络号和掩码。 pcap_open_live()： 函数用于打开网络设备，并且返回用于捕获网络数据包的数据包捕获描述字。对于此网络设备的操作都要基于此网络设备描述字。 pcap_compile()： 函数用于将用户制定的过滤策略编译到过滤程序中。 pcap_setfilter()：函数用于设置过滤器。 pcap_loop()：函数 pcap_dispatch() 函数用于捕获数据包，捕获后还可以进行处理，此外 pcap_next() 和 pcap_next_ex() 两个函数也可以用来捕获数据包。 pcap_close()：函数用于关闭网络设备，释放资源。 pcap_dump_open用于打开保存的文件 pcap_dump用于输出数据到文件。 分析Pcap文件这里给出用于读取Pcap文件的结构体。读者可以从中看出Pcap文件的结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213/* Wireshark File Formate +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | PCAP File Header | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | PCAP Package Header | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Ethernet frame header | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | IP Header | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SCTP Package | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/typedef unsigned char _1Byte;typedef unsigned short _2Byte;typedef unsigned int _4Byte;#define PCAP_FILE_HEADER_SIZE 24 //24个字节#define PACKET_HEADER_SIZE 16 //16个字节#define MAC_HEADER_SIZE 14 //14个字节#define IP_HEADER_SIZE 20 //20个字节#define ICMP_HEADER_SIZE 8 //8个字节#define TCP_HEADER_SIZE 20 //20个字节#define UDP_HEADER_SIZE 8 //8个字节/* PCAP File Header 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magic Number(0xA1B2C3D4) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magjor Version(0x02) | Minor Version(0x04) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Time Zone(0) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Time Stamp Accuracy(0) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Snapshot Length(0xFFFF) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Link Layer Type(0x01) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/struct PcapFileHeader&#123; _4Byte magic; //4Byte：标记文件开始，并用来识别文件自己和字节顺序。 _2Byte majorVersion; //2Byte： 当前文件主要的版本号，一般为 0x0200 _2Byte minorVersion; //2Byte： 当前文件次要的版本号，一般为 0x0400 _4Byte timezone; //4Byte：当地的标准时间，如果用的是GMT则全零 _4Byte sigFlags; //4Byte：时间戳的精度 _4Byte snapLen; //4Byte：最大的存储长度 _4Byte linkType; //4Byte：链路类型&#125;;/* Packet Header 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Seconds | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Microseconds | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | CapLen | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Len | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/struct PacketHeader&#123; _4Byte seconds; //4Byte 秒计时,被捕获时间的高位，单位是seconds _4Byte microseconds; //4Byte 微秒计时,被捕获时间的低位，单位是microseconds _4Byte capLen; //4Byte 当前数据区的长度，即抓取到的数据帧长度，不包括Packet Header本身的长度，单位是 Byte _4Byte len; //4Byte 离线数据长度：网络中实际数据帧的长度，一般不大于caplen，多数情况下和Caplen数值相等&#125;;/* IP Header 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Version| IHL |Type of Service| Total Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Identification |Flags| Fragment Offset | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Time to Live | Protocol | Header Checksum | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Destination Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Options | Padding | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/struct IPHeader&#123; /*----------第一行-------------------*/ union//共一个字节 &#123; _1Byte version;//版本号 _1Byte headerLength;//包头长度,指明IPv4协议包头长度的字节数包含多少个32位 &#125;; _1Byte serviceType;//区分服务 _2Byte totalLength;//总长度 /*----------第二行-------------------*/ _2Byte identification;//标识 union &#123; _2Byte flags;//标志,当封包在传输过程中进行最佳组合时使用的3个bit的识别记号 _2Byte fragmentOffset;//片偏移 &#125;; /*----------第三行-------------------*/ _1Byte timeToLive;//生存时间 _1Byte protocol;//协议 _2Byte headerChecksum;//首部检验和 /*----------第四行-------------------*/ _4Byte sourceAddress;//源地址 /*----------第五行-------------------*/ _4Byte destinationAddress;//目标地址&#125;;//MAC帧信息struct MACHeader&#123; _1Byte destinationAddress[6]; _1Byte sourceAddress[6]; _2Byte type;&#125;;/* ICMPHeader 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | type | code | Header Checksum | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Identification | serial | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/struct ICMPHeader &#123; _1Byte type; //类型 _1Byte code; //代码 _2Byte headerChecksum;//首部检验和 _2Byte identification;//标识 _2Byte serial;//序列号&#125;;/* TCP Header 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source port | Destination port | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Serial | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Acknowledgement Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |DataOffset|Reserve|u|a|p|r|s|f| Window | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Checksum | Urgent Pointer | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Options | Padding | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/struct TCPHeader&#123; _2Byte sourcePort;//源端口 _2Byte destinationPort;//目的端口 _4Byte serial;//序号 _4Byte acknowledgementNumber;//确认号 union&#123;//共2个字节 _2Byte dataOffset;//数据偏移 _2Byte reserve;//保留 _2Byte urg;//紧急 _2Byte ack;//确认 _2Byte psh;//推送 _2Byte rst;//复位 _2Byte syn;//同步 _2Byte fin;//终止 &#125;; _2Byte window;//窗口 _2Byte checksum;//检验和 _2Byte urgentpointer;//紧急指针&#125;;struct UDPHeader&#123; _2Byte sourcePort;//源端口 _2Byte destinationPort;//目的端口 _2Byte length;//长度 _2Byte checksum;//检验和&#125;; 分析的过程即是个读取文件的过程，在此不再赘述。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux--实现简单的ls功能]]></title>
    <url>%2F2018%2F11%2F18%2FLinux-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84ls%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[利用Linux C实现简单的ls功能，其中包括： -a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)。 -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出。 -R 若目录下有文件，则以下之文件亦皆递归依序列出。 -d 显示目录名称而非其内容。 -i 显示文件和目录的inode编号。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//ls_command.cpp#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;dirent.h&gt;#include &lt;stdbool.h&gt;#define PARAM_TYPE_NUM 6//参数种类#define DESTINATION_PARAM 0#define a_PARAM 1#define d_PARAM 2#define i_PARAM 3#define l_PARAM 4#define R_PARAM 5void handle_params(int argc, char* argv[], bool params[], char* optstring);void handle_ls_command(bool params[], char* argv[]);void printDir(char *dir, int depth, bool params[]);void handle_params(int argc, char* argv[], bool params[], char* optstring)&#123; int opt; while((opt = getopt(argc, argv, optstring)) != -1)&#123; switch(opt)&#123; case 'a': params[a_PARAM] = true; break; case 'd': params[d_PARAM] = true; break; case 'i': params[i_PARAM] = true; break; case 'l': params[l_PARAM] = true; break; case 'R': params[R_PARAM] = true; break; case '?': printf("ls: unknown option: %c\n", optopt); optind--; break; default: break; &#125; &#125; if(optind &lt; argc)&#123; params[DESTINATION_PARAM] = true; &#125;&#125;void handle_ls_command(bool params[], char* argv[])&#123; if(params[DESTINATION_PARAM] != true)&#123; printDir(".", 0, params); &#125;else&#123; printDir(argv[optind], 0, params); &#125;&#125;void printDir(char *dir, int depth, bool params[])&#123; DIR *destination_directory = opendir(dir); if(destination_directory == NULL)&#123;//如果打开失败，给出提示，并退出。 printf("ls: 打开文件夹 %s 失败。\n", dir); // exit(-1); return; &#125; struct dirent *entry; struct stat statbuf; chdir(dir);//更换工作路径 while((entry = readdir(destination_directory)) != NULL)&#123; lstat(entry-&gt;d_name, &amp;statbuf); //-d 显示目录名称而非其内容 if(params[d_PARAM] == true)&#123; printf("%*s%s/ \n", depth, " ", dir); //-i 显示文件和目录的索引节点号 if(params[i_PARAM] == true)&#123; printf("%*s%ld\n", depth, " inode:", statbuf.st_ino); &#125; //-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 if(params[l_PARAM] == true)&#123; printf("%*s%d\t", depth, " 权限：", statbuf.st_mode);//权限 printf("%*s%d\t", depth, " 拥有者：", statbuf.st_uid);//拥有者 printf("%*s%d\t", depth, " 组ID：", statbuf.st_gid);//组名 printf("%*s%ld 字节\n", depth, " 文件大小：", statbuf.st_size);//文件大小 &#125; exit(0); &#125; if(S_ISDIR(statbuf.st_mode))&#123;//如果是目录 if(params[a_PARAM] == false &amp;&amp; (strcmp(entry-&gt;d_name, ".")==0 || strcmp(entry-&gt;d_name, "..")==0) )&#123; //不显示 . 和 .. 文件夹 continue; &#125; printf("%*s%s/ \n", depth, " ", entry-&gt;d_name); //-i 显示文件和目录的索引节点号 if(params[i_PARAM] == true)&#123; printf("%*s%ld\n", depth, " inode:", statbuf.st_ino); &#125; //-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 if(params[l_PARAM] == true)&#123; printf("%*s%d\t", depth, " 权限：", statbuf.st_mode);//权限 printf("%*s%d\t", depth, " 拥有者：", statbuf.st_uid);//拥有者 printf("%*s%d\t", depth, " 组ID：", statbuf.st_gid);//组名 printf("%*s%ld 字节\n", depth, " 文件大小：", statbuf.st_size);//文件大小 &#125; //-R 若目录下有文件，则以下之文件亦皆递归依序列出 //若没有，直接跳出第一次循环即可 if(params[R_PARAM] == true)&#123; printDir(entry-&gt;d_name, depth + 4, params); &#125; &#125;else&#123;//一般文件 //如果没有 -a 则忽略以.开头的文件 if(params[a_PARAM] == false &amp;&amp; (entry-&gt;d_name[0] == '.'))&#123; continue; &#125; printf("%*s%s \n", depth, " ", entry-&gt;d_name);//只列出名字 //-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 if(params[l_PARAM] == true)&#123; printf("%*s%d\t", depth, " 权限：", statbuf.st_mode);//权限 printf("%*s%d\t", depth, " 拥有者：", statbuf.st_uid);//拥有者 printf("%*s%d\t", depth, " 组ID：", statbuf.st_gid);//组名 printf("%*s%ld 字节\n", depth, " 文件大小：", statbuf.st_size);//文件大小 &#125; //-i 显示文件和目录的索引节点号 if(params[i_PARAM] == true)&#123; printf("%*s%ld\n", depth, " inode:", statbuf.st_ino); &#125; &#125; &#125; chdir(".."); closedir(destination_directory);&#125;int main(int argc, char* argv[])&#123; bool params[PARAM_TYPE_NUM] = &#123;false&#125;;//首先全部设为false handle_params(argc, argv, params, "alRdi::"); handle_ls_command(params, argv); exit(0);&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--3D图形斜投影]]></title>
    <url>%2F2018%2F10%2F28%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-3D%E5%9B%BE%E5%BD%A2%E6%96%9C%E6%8A%95%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[平行投影分为正投影和斜投影。当投影线与投影面不垂直，也就是说，投影线与投影面相倾斜时，所得到的物体的投影叫做斜投影。 利用矩阵变换同样可以得到3D图形几何变换，我将图形学–图形几何变换一文中的矩阵类进行修改，再加上重写了一个CPoint3D类，就可以简单实现3D图形的 斜等测轴测投影图 和 斜二测轴测投影图 。 使用时，直接调用函数 CPoint3D::cavalier_projection 和 CPoint3D::cabinet_projection 即可。 读者若有其他变换需求，只需模仿这两种变换，将变换矩阵的值进行修改即可。CPoint3D.h12345678910111213141516171819202122232425#pragma onceclass CPoint3D&#123;public: CPoint3D(); ~CPoint3D(); CPoint3D(int x, int y, int z);private: int x; int y; int z; public: void setX(int value); int getX(); void setY(int value); int getY(); void setZ(int value); int getZ(); static void CPoint3DToCPoint(CPoint3D points_3d[], CPoint points[], int point_number); static void cavalier_projection(CPoint3D points_3d[], CPoint points[], int point_number);//斜等测轴测投影图 static void cabinet_projection(CPoint3D points_3d[], CPoint points[], int point_number); //斜二测轴测投影图&#125;; CPoint3D.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include "stdafx.h"#include "CPoint3D.h"#include "MatrixTransformation3D.h"CPoint3D::CPoint3D()&#123; this-&gt;x = 0; this-&gt;y = 0; this-&gt;z = 0;&#125;CPoint3D::~CPoint3D()&#123;&#125;CPoint3D::CPoint3D(int x, int y, int z)&#123; this-&gt;x = x; this-&gt;y = y; this-&gt;z = z;&#125;void CPoint3D::setX(int value)&#123; this-&gt;x = value;&#125;int CPoint3D::getX()&#123; return x;&#125;void CPoint3D::setY(int value)&#123; this-&gt;y = value;&#125;int CPoint3D::getY()&#123; return y;&#125;void CPoint3D::setZ(int value)&#123; this-&gt;z = value;&#125;int CPoint3D::getZ()&#123; return z;&#125;void CPoint3D::CPoint3DToCPoint(CPoint3D points_3d[], CPoint points[], int point_number)&#123; for(int i = 0; i &lt; point_number; i++) &#123; points[i].x = points_3d[i].getX(); points[i].y = points_3d[i].getY(); &#125;&#125;//斜等测轴测投影图void CPoint3D::cavalier_projection(CPoint3D points_3d[], CPoint points[], int point_number)&#123; const double PI = 3.1415926535; MatrixTransformation3D matrix_transformation_3d(points_3d, point_number); matrix_transformation_3d.oblique_projection(PI / 4, PI / 4); //alpha = PI / 4, beta = PI / 4 matrix_transformation_3d.matrixTo3DPoint(points_3d, point_number); CPoint3DToCPoint(points_3d, points, point_number);&#125;//斜二测轴测投影图void CPoint3D::cabinet_projection(CPoint3D points_3d[], CPoint points[], int point_number)&#123; const double PI = 3.1415926535; MatrixTransformation3D matrix_transformation_3d(points_3d, point_number); matrix_transformation_3d.oblique_projection(63.4 * PI / 180, PI / 4); //alpha = 63.4 * PI / 180, beta = PI / 4 matrix_transformation_3d.matrixTo3DPoint(points_3d, point_number); CPoint3DToCPoint(points_3d, points, point_number);&#125; MatrixTransformation3D.h1234567891011121314151617181920212223242526272829303132333435#pragma once#include "CPoint3D.h"class MatrixTransformation3D&#123;public: MatrixTransformation3D(); ~MatrixTransformation3D();private: int row;//矩阵行数 int column;//矩阵列数 double* pointMatrix;//点矩阵 double transforMatrix[4][4];//变换矩阵public: MatrixTransformation3D(CPoint3D points[], int pointNumber);private: bool setMatrixElement(int row, int column, double value); bool setMatrixElement(int row, int column, double value, double matrix[]); double getMatrixElement(int row, int column); double getMatrixElement(int row, int column, double matrix[]); bool setTransforMatrixElement(int row, int column, double value); void matrixMultiplication(); int round(double value);public: CPoint3D* MatrixTransformation3D::matrixTo3DPoint(CPoint3D points[], int point_number);//矩阵转为点数组 void MatrixTransformation3D::oblique_projection(double alpha, double beta);//斜投影&#125;; MatrixTransformation3D.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &quot;stdafx.h&quot;#include &quot;MatrixTransformation3D.h&quot;MatrixTransformation3D::MatrixTransformation3D()&#123; row = 0; column = 0; pointMatrix = NULL;&#125;MatrixTransformation3D::MatrixTransformation3D(CPoint3D points[], int pointNumber)&#123; row = pointNumber; column = 4; pointMatrix = new double[row * column]; for (int i = 1; i &lt;= row; i++) &#123; setMatrixElement(i, 1, points[i - 1].getX()); setMatrixElement(i, 2, points[i - 1].getY()); setMatrixElement(i, 3, points[i - 1].getZ()); setMatrixElement(i, 4, 1); &#125;&#125;MatrixTransformation3D::~MatrixTransformation3D()&#123; delete[] pointMatrix;&#125;bool MatrixTransformation3D::setMatrixElement(int row, int column, double value)&#123; return setMatrixElement(row, column, value, pointMatrix);&#125;bool MatrixTransformation3D::setMatrixElement(int row, int column, double value, double matrix[])&#123; int realIndex = (row - 1) * this-&gt;column + column - 1; if (realIndex &lt; this-&gt;row * this-&gt;column &amp;&amp; realIndex &gt;= 0) &#123; matrix[realIndex] = value; return true; &#125; return false;&#125;double MatrixTransformation3D::getMatrixElement(int row, int column)&#123; return getMatrixElement(row, column, pointMatrix);&#125;double MatrixTransformation3D::getMatrixElement(int row, int column, double matrix[])&#123; int realIndex = (row - 1) * this-&gt;column + column - 1; if (realIndex &lt; this-&gt;row * this-&gt;column &amp;&amp; realIndex &gt;= 0) &#123; return matrix[realIndex]; &#125; return 0;&#125;bool MatrixTransformation3D::setTransforMatrixElement(int row, int column, double value)&#123; if (row &lt;= this-&gt;row &amp;&amp; row &gt; 0 &amp;&amp; column &lt;= this-&gt;column &amp;&amp; column &gt; 0) &#123; transforMatrix[row - 1][column - 1] = value; return true; &#125; return false;&#125;void MatrixTransformation3D::matrixMultiplication()&#123; double* result = new double[row * column]; double tempResult; for (int m = 0; m &lt; row; m++) &#123; for (int s = 0; s &lt; column; s++) &#123; tempResult = 0.0; //变量使用前初始化,否则结果具有不确定性 for (int n = 0; n &lt; column; n++) &#123; tempResult += getMatrixElement(m + 1, n + 1) * transforMatrix[n][s]; &#125; setMatrixElement(m + 1, s + 1, tempResult, result); &#125; &#125; double* tempPointer = this-&gt;pointMatrix; this-&gt;pointMatrix = result; delete[] tempPointer;&#125;int MatrixTransformation3D::round(double value)&#123; return (int)(value + 0.5);&#125;CPoint3D* MatrixTransformation3D::matrixTo3DPoint(CPoint3D points[], int point_number)&#123; for (int i = 1; i &lt;= point_number; i++) &#123; points[i - 1].setX(round(getMatrixElement(i, 1))); points[i - 1].setY(round(getMatrixElement(i, 2))); points[i - 1].setZ(round(getMatrixElement(i, 3))); &#125; return points;&#125;//斜投影void MatrixTransformation3D::oblique_projection(double alpha, double beta)&#123; setTransforMatrixElement(1, 1, 1); setTransforMatrixElement(1, 2, 0); setTransforMatrixElement(1, 3, 0); setTransforMatrixElement(1, 4, 0); setTransforMatrixElement(2, 1, 0); setTransforMatrixElement(2, 2, 1); setTransforMatrixElement(2, 3, 0); setTransforMatrixElement(2, 4, 0); setTransforMatrixElement(3, 1, -cos(beta) / tan(alpha)); setTransforMatrixElement(3, 2, -sin(beta) / tan(alpha)); setTransforMatrixElement(3, 3, 0); setTransforMatrixElement(3, 4, 0); setTransforMatrixElement(4, 1, 0); setTransforMatrixElement(4, 2, 0); setTransforMatrixElement(4, 3, 0); setTransforMatrixElement(4, 4, 1); matrixMultiplication();&#125;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>几何变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--图形几何变换]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%9B%BE%E5%BD%A2%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[二维图形基本几何变换是指相对于坐标原点和坐标轴进行的几何变换，包括平移（Translate）、比例（Scale）、旋转（Rotate）、反射（Reflect）和错切（shear）5种变换。物体变换物体变换是通过变换物体上每一个顶点实现的，因此以点的二维基本几何变换为例讲解二维图形基本几何变换矩阵。 下面给出C++实现二维图形基本几何变换的具体代码。算法中只包含平移和旋转两种变换。使用时，直接调用函数translation 和 whirling 即可。读者若有其他变换需求，只需模仿这两种变换，将变换矩阵的值进行修改即可。 MatrixTransformation.h123456789101112131415161718192021222324252627282930313233class MatrixTransformation&#123;public: MatrixTransformation(); ~MatrixTransformation(); private: int row;//矩阵行数 int column;//矩阵列数 double* pointMatrix;//点矩阵 double transforMatrix[3][3];//变换矩阵public: MatrixTransformation(CPoint points[], int pointNumber);private: bool setMatrixElement(int row, int column, double value); bool setMatrixElement(int row, int column, double value, double matrix[]); double getMatrixElement(int row, int column); double getMatrixElement(int row, int column, double matrix[]); bool setTransforMatrixElement(int row, int column, double value); void matrixMultiplication();public: CPoint* matrixToPoint(CPoint points[], int point_number);//矩阵转为点数组 void translation(int offset_x, int offset_y);//平移 void whirling(double angle);//旋转 void whirling(int offset_x, int offset_y, double angle);//绕点(offset_x, offset_y)旋转&#125;; MatrixTransformation.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136MatrixTransformation::MatrixTransformation()&#123; row = 0; column = 0; pointMatrix = NULL;&#125;MatrixTransformation::MatrixTransformation(CPoint points[], int pointNumber)&#123; row = pointNumber; column = 3; pointMatrix = new double[row * column]; for(int i = 1; i &lt;= row; i++) &#123; setMatrixElement(i, 1, points[i - 1].x); setMatrixElement(i, 2, points[i - 1].y); setMatrixElement(i, 3, 1); &#125;&#125;MatrixTransformation::~MatrixTransformation()&#123; delete[] pointMatrix;&#125;bool MatrixTransformation::setMatrixElement(int row, int column, double value)&#123; return setMatrixElement(row, column, value, pointMatrix);&#125;bool MatrixTransformation::setMatrixElement(int row, int column, double value, double matrix[])&#123; int realIndex = (row - 1) * this-&gt;column + column - 1; if (realIndex &lt; this-&gt;row * this-&gt;column &amp;&amp; realIndex &gt;= 0) &#123; matrix[realIndex] = value; return true; &#125; return false;&#125;double MatrixTransformation::getMatrixElement(int row, int column)&#123; return getMatrixElement(row, column, pointMatrix);&#125;double MatrixTransformation::getMatrixElement(int row, int column, double matrix[])&#123; int realIndex = (row - 1) * this-&gt;column + column - 1; if (realIndex &lt; this-&gt;row * this-&gt;column &amp;&amp; realIndex &gt;= 0) &#123; return matrix[realIndex]; &#125; return 0;&#125;bool MatrixTransformation::setTransforMatrixElement(int row, int column, double value)&#123; if (row &lt;= 3 &amp;&amp; row &gt; 0 &amp;&amp; column &lt;= 3 &amp;&amp; column &gt; 0) &#123; transforMatrix[row - 1][column - 1] = value; return true; &#125; return false;&#125;void MatrixTransformation::matrixMultiplication()&#123; double* result = new double[row * column]; int tempResult; for (int m = 0; m &lt; row; m++) &#123; for (int s = 0; s &lt; column; s++) &#123; tempResult = 0; //变量使用前初始化,否则结果具有不确定性 for (int n = 0; n &lt; column; n++) &#123; tempResult += getMatrixElement(m + 1, n + 1) * transforMatrix[n][s]; &#125; setMatrixElement(m + 1, s + 1, tempResult, result); &#125; &#125; double* tempPointer = this-&gt;pointMatrix; this-&gt;pointMatrix = result; delete[] tempPointer;&#125;CPoint* MatrixTransformation::matrixToPoint(CPoint points[], int point_number)&#123; for(int i = 1; i &lt;= point_number; i++) &#123; points[i - 1].x = getMatrixElement(i, 1); points[i - 1].y = getMatrixElement(i, 2); &#125; return points;&#125;void MatrixTransformation::translation(int offset_x, int offset_y)&#123; setTransforMatrixElement(1, 1, 1); setTransforMatrixElement(1, 2, 0); setTransforMatrixElement(1, 3, 0); setTransforMatrixElement(2, 1, 0); setTransforMatrixElement(2, 2, 1); setTransforMatrixElement(2, 3, 0); setTransforMatrixElement(3, 1, offset_x); setTransforMatrixElement(3, 2, offset_y); setTransforMatrixElement(3, 3, 1); matrixMultiplication();&#125;void MatrixTransformation::whirling(double angle)&#123; setTransforMatrixElement(1, 1, cos(angle)); setTransforMatrixElement(1, 2, sin(angle)); setTransforMatrixElement(1, 3, 0); setTransforMatrixElement(2, 1, -sin(angle)); setTransforMatrixElement(2, 2, cos(angle)); setTransforMatrixElement(2, 3, 0); setTransforMatrixElement(3, 1, 0); setTransforMatrixElement(3, 2, 0); setTransforMatrixElement(3, 3, 1); matrixMultiplication();&#125;void MatrixTransformation::whirling(int offset_x, int offset_y, double angle)&#123; translation(-offset_x, -offset_y); whirling(angle); translation(offset_x, offset_y);&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>几何变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--扫描线种子填充算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%A7%8D%E5%AD%90%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法描述：种子填充算法原理和程序都很简单, 但由于多次递归, 费时、费内存, 效率不高。为了减少递归次数, 提高效率可以采用扫描线种子填充算法。 算法的基本过程如下: 当给定种子点 (x, y) 时, 首先填充种子点所在扫描线上的位于给定区域的一个区段, 然后确定与这一区段相连通的上、下两条扫描线上位于给定区域内的区段, 并依次保存下来。反复这个过程, 直到填充结束。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * begin_point 是起始点 * boundaryColor 是边界色 * fillColor 是填充色 * */void scanLineSeedFillingAlgorithm(CPoint begin_point, COLORREF boundaryColor, COLORREF fillColor, CDC* pDC)&#123; std::stack&lt;CPoint&gt; stack;//使用STL自带的栈容器 stack.push(begin_point);//将起点先入栈 CPoint* currentPoint = NULL;//当前操作的点 int x_left = 0, x_right = 0; while (!stack.empty())//栈不空时进行循环 &#123; currentPoint = &amp;stack.top();//访问栈顶元素 stack.pop();//删除栈顶元素 pDC-&gt;SetPixelV(*currentPoint, fillColor);//填充颜色 x_left = fillThisLine(currentPoint-&gt;x - 1, currentPoint-&gt;y, boundaryColor, fillColor, false, pDC) + 1; x_right = fillThisLine(currentPoint-&gt;x + 1, currentPoint-&gt;y, boundaryColor, fillColor, true, pDC) - 1; int tempY = currentPoint-&gt;y; searchNewLineSeed(&amp;stack, x_left, x_right, tempY + 1, boundaryColor, fillColor, pDC); searchNewLineSeed(&amp;stack, x_left, x_right, tempY - 1, boundaryColor, fillColor, pDC); &#125;&#125;/** * x 是该点横坐标 * y 是该点纵坐标 * boundaryColor 是边界色 * fillColor 是填充色 * sign是填充标志，当sign是false时，向左扫描；当sign是true时，向右扫描。 * */int fillThisLine(int x, int y, COLORREF boundaryColor, COLORREF fillColor, BOOL sign, CDC* pDC)&#123; COLORREF currentColor = pDC-&gt;GetPixel(x, y); if (sign == false)//当sign是false时，向左扫描。 &#123; while (currentColor != boundaryColor)//当当前颜色不是边界线颜色时进行循环，否则跳出循环。 &#123; pDC-&gt;SetPixelV(x, y, fillColor);//向左填充颜色 currentColor = pDC-&gt;GetPixel(--x, y);//获取左侧颜色 &#125; &#125; else//当sign是true时，向右扫描。 &#123; while (currentColor != boundaryColor)//当当前颜色不是边界线颜色时进行循环，否则跳出循环。 &#123; pDC-&gt;SetPixelV(x, y, fillColor);//向右填充颜色 currentColor = pDC-&gt;GetPixel(++x, y);//获取右侧颜色 &#125; &#125; return x;&#125;/** * stack是栈指针 * x_left 是左边界 * x_right 是右边界 * y 是当前扫描线 * boundaryColor 是边界色 * fillColor 是填充色 */ void searchNewLineSeed(std::stack&lt;CPoint&gt; *stack, int x_left, int x_right, int y, COLORREF boundaryColor, COLORREF fillColor, CDC* pDC)&#123; BOOL findNewSeed = false; for(; x_left &lt;= x_right; x_left++) &#123; if(pDC-&gt;GetPixel(x_left, y) != boundaryColor &amp;&amp; pDC-&gt;GetPixel(x_left, y) != fillColor) &#123; findNewSeed = true; break; &#125; &#125; if(findNewSeed) &#123; stack-&gt;push(CPoint(x_left, y)); &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>填充算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--区域填充算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法描述：区域填充是指从区域内的某一个象素点（种子点）开始，由内向外将填充色扩展到整个区域内的过程。区域是指已经表示成点阵形式的填充图形，它是相互连通的一组像素的集合。 区域填充算法（边界填充算法和泛填充算法）是根据区域内的一个已知象素点（种子点）出发，找到区域内其他象素点的过程，所以把这一类算法也成为种子填充算法。 下面给出八连通区域填充算法（四连通区域填充算法类似）123456789101112131415161718192021222324252627282930313233343536373839404142/** * begin_point 是起始点 * boundaryColor 是边界色 * fillColor 是填充色 * */ void eightAdjacentPointFillingAlgorithm(CPoint begin_point, COLORREF boundaryColor, COLORREF fillColor, CDC* pDC)&#123; std::stack&lt;CPoint&gt; stack;//使用STL自带的栈容器 stack.push(begin_point);//将起点先入栈 CPoint* currentPoint = NULL;//当前操作的点 while(!stack.empty())//栈不空时进行循环 &#123; currentPoint = &amp;stack.top();//访问栈顶元素 stack.pop();//删除栈顶元素 pDC-&gt;SetPixelV(*currentPoint, fillColor);//填充颜色 isFilling(&amp;stack, currentPoint-&gt;x - 1, currentPoint-&gt;y, boundaryColor, fillColor, pDC);//左侧点 isFilling(&amp;stack, currentPoint-&gt;x - 1, currentPoint-&gt;y - 1, boundaryColor, fillColor, pDC);//左上点 isFilling(&amp;stack, currentPoint-&gt;x, currentPoint-&gt;y - 1, boundaryColor, fillColor, pDC);//上侧点 isFilling(&amp;stack, currentPoint-&gt;x + 1, currentPoint-&gt;y + 1, boundaryColor, fillColor, pDC);//右上点 isFilling(&amp;stack, currentPoint-&gt;x + 1, currentPoint-&gt;y, boundaryColor, fillColor, pDC);//右侧点 isFilling(&amp;stack, currentPoint-&gt;x + 1, currentPoint-&gt;y - 1, boundaryColor, fillColor, pDC);//右下点 isFilling(&amp;stack, currentPoint-&gt;x, currentPoint-&gt;y - 1, boundaryColor, fillColor, pDC);//下侧点 isFilling(&amp;stack, currentPoint-&gt;x - 1, currentPoint-&gt;y - 1, boundaryColor, fillColor, pDC);//左下点 &#125;&#125;/** * stack 是栈指针 * boundaryColor 是边界色 * fillColor 是填充色 */ void isFilling(std::stack&lt;CPoint&gt; *stack, int x, int y, COLORREF boundaryColor, COLORREF fillColor, CDC* pDC)&#123; COLORREF currentColor = pDC-&gt;GetPixel(x, y);;//获得当前操作点颜色 if (currentColor != boundaryColor &amp;&amp; currentColor != fillColor) &#123; stack-&gt;push(CPoint(x, y)); &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>填充算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--边缘填充算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E8%BE%B9%E7%BC%98%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法描述：边缘填充算法是先求出多边形的每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取为补色（或反色）。按任意顺序处理完多边形的所有边后，就完成了多边形的填充任务。 边缘填充算法利用了图像处理中的求“补”或求“反”的概念，对于黑白图像，求补就是把RGB(255,255,255)（白色）的像素置为RGB(0,0,0)（黑色），反之亦然；对于彩色图像，求补就是将背景色置为填充色，反之亦然。求补的一条基本性质是一个像素求补两次就恢复为原色。如果多边形内部的像素被求补偶数次，保持原色，如果被求补奇数次，显示填充色。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * points 是点数组 * point_num 是点的个数 * foregroundColor 是前景色 * backgroundColor 是背景色 * fence 是栅栏 * */void edgeFillingAlgorithm(CPoint points[], int point_num, COLORREF foregroundColor, COLORREF backgroundColor, int fence, CDC *pDC)&#123; int yMin, yMax;//边的最小y和最大y //x,y为当前点x、y坐标，reciprocalOfSlope为斜率分之一，1/k double x, reciprocalOfSlope; int y; for (int i = 0; i &lt; point_num; i++) &#123; int j = (i + 1) % point_num;//j为相对于i的下一个点 if (points[i].y - points[j].y != 0) &#123; reciprocalOfSlope = (points[i].x - points[j].x) * 1.0 / (points[i].y - points[j].y); //TODO：以下处理，得到每条边的y的最大值和最小值 if (points[i].y &lt; points[j].y)//斜率不为0时 &#123; yMin = points[i].y; yMax = points[j].y; x = points[i].x; &#125; else &#123; yMin = points[j].y; yMax = points[i].y; x = points[j].x; &#125; for (y = yMin; y &lt; yMax; y++)//沿每条扫描线处理 &#123; //对每条扫描线与边的交点的右侧像素循环，其中max_X是包围圈的右边界 if(x &lt; fence) &#123; for (int tempX = Round(x); tempX &lt; fence; tempX++) &#123; if (pDC-&gt;GetPixel(tempX, y) == foregroundColor) &#123; pDC-&gt;SetPixelV(tempX, y, backgroundColor); &#125; else &#123; pDC-&gt;SetPixelV(tempX, y, foregroundColor); &#125; &#125; &#125; else &#123; for (int tempX = fence; tempX &lt; x; tempX++) &#123; if (pDC-&gt;GetPixel(tempX, y) == foregroundColor) &#123; pDC-&gt;SetPixelV(tempX, y, backgroundColor); &#125; else &#123; pDC-&gt;SetPixelV(tempX, y, foregroundColor); &#125; &#125; &#125; x = x + reciprocalOfSlope; &#125; &#125; else //斜率为0时 &#123; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>填充算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--有效边表填充算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E6%9C%89%E6%95%88%E8%BE%B9%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法描述：有效边表填充算法通过维护边表和有效边表，避开了扫描线与多边形所有边求交的复杂运算。 填充原理是按照扫描线从小到大的移动顺序，计算当前扫描线与有效边的交点，然后把这些交点按x值递增的顺序进行排序、配对，以确定填充区间，最后用指定颜色填充区间内的所有像素，即完成填充工作。有效边表填充算法已成为目前最为有效的多边形填充算法之一。 Edge.h12345678910111213141516#pragma onceclass Edge&#123;public: Edge(); ~Edge(); Edge(double x, int yMax, double reciprocalOfSlope, Edge* pNext); void setEdge(double x, int yMax, double reciprocalOfSlope, Edge* pNext); void reUseEdge();public: double x; int yMax; double reciprocalOfSlope;//斜率分之一，1/k Edge* pNext;&#125;; Edge.cpp1234567891011121314151617181920212223242526272829303132333435363738#include "stdafx.h"#include "Edge.h"Edge::Edge()&#123; x = 0.0; yMax = 0; reciprocalOfSlope = 0.0; pNext = NULL;&#125;Edge::~Edge()&#123;&#125;Edge::Edge(double x, int yMax, double reciprocalOfSlope, Edge* pNext)&#123; this-&gt;x = x; this-&gt;yMax = yMax; this-&gt;reciprocalOfSlope = reciprocalOfSlope; this-&gt;pNext = pNext;&#125;void Edge::setEdge(double x, int yMax, double reciprocalOfSlope, Edge* pNext)&#123; this-&gt;x = x; this-&gt;yMax = yMax; this-&gt;reciprocalOfSlope = reciprocalOfSlope; this-&gt;pNext = pNext;&#125;void Edge::reUseEdge()&#123; this-&gt;x = this-&gt;x + this-&gt;reciprocalOfSlope; this-&gt;pNext = NULL;&#125; Bucket.h12345678910111213141516171819#pragma once#include "Edge.h"class Bucket&#123;public: Bucket(); ~Bucket(); Bucket(int scanLine, Edge* pEdge, Bucket* pNext); static Bucket* creatBucket(CPoint points[], int points_num); static Bucket* creatEdgeTable(CPoint points[], Edge edges[], int points_num, Bucket* headBucket); static void addEdge(Bucket* currentBucket, Edge* edge);public: int scanLine; Edge* pEdge; Bucket* pNext;&#125;; Bucket.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include "stdafx.h"#include "Bucket.h"Bucket::Bucket()&#123; scanLine = 0; pEdge = NULL; pNext = NULL;&#125;Bucket::~Bucket()&#123;&#125;Bucket::Bucket(int scanLine, Edge* pEdge, Bucket* pNext)&#123; this-&gt;scanLine = scanLine; this-&gt;pEdge = pEdge; this-&gt;pNext = pNext;&#125;Bucket* Bucket::creatBucket(CPoint points[], int points_num)&#123; if (points_num == 0) &#123; return NULL; &#125; int scanMin = points[0].y, scanMax = points[0].y;//确定扫描线的最小值和最大值。初始值使用第一个点的y值。 for (int i = 1; i &lt; points_num; i++) &#123; if (points[i].y &lt; scanMin) &#123; scanMin = points[i].y;//扫描线的最小值 &#125; if (points[i].y &gt; scanMax) &#123; scanMax = points[i].y;//扫描线的最大值 &#125; &#125; //TODO: 以下是创建桶的代码，此时桶上不加入边 Bucket *headBucket = new Bucket(scanMin, NULL, NULL);//建立桶的头结点 Bucket *currentBucket = headBucket; for (int i = scanMin + 1; i &lt;= scanMax; i++)//建立桶的其它结点 &#123; currentBucket-&gt;pNext = new Bucket(i, NULL, NULL);//新建一个桶结点 currentBucket = currentBucket-&gt;pNext;//使currentBucket指向新建的桶结点 &#125; return headBucket;&#125;Bucket* Bucket::creatEdgeTable(CPoint points[], Edge edges[], int points_num, Bucket* headBucket)&#123; Bucket *currentBucket = NULL; Edge *currentEdge = NULL; for (int i = 0; i &lt; points_num; i++)//访问每个顶点 &#123; int j = (i + 1) % points_num;//边的第二个顶点，points[i]和points[j]构成一条边 currentBucket = headBucket;//从桶链表的头结点开始循环 if (points[j].y &gt; points[i].y)//若终点比起点高 &#123; while (currentBucket-&gt;scanLine != points[i].y)//在桶内寻找该边的yMin &#123; currentBucket = currentBucket-&gt;pNext;//移到下一个桶结点 &#125;//跳出循环时，找到对应的桶，即为currentBucket edges[i].setEdge(points[i].x, points[j].y, (points[j].x - points[i].x) * 1.0 / (points[j].y - points[i].y), NULL);//将该边记入数组edges中 addEdge(currentBucket, &amp;edges[i]);//将该边加入桶中 &#125; if (points[j].y &lt; points[i].y)//终点比起点低 &#123; while (currentBucket-&gt;scanLine != points[j].y)//在桶内寻找该边的yMin &#123; currentBucket = currentBucket-&gt;pNext;//移到下一个桶结点 &#125;//跳出循环时，找到对应的桶，即为currentBucket edges[i].setEdge(points[j].x, points[i].y, (points[i].x - points[j].x) * 1.0 / (points[i].y - points[j].y), NULL);//将该边记入数组edges中 addEdge(currentBucket, &amp;edges[i]);//将该边加入桶中 &#125; &#125; return headBucket;&#125;//按照x的大小顺序将边加入桶中void Bucket::addEdge(Bucket* currentBucket, Edge* edge)&#123; if (currentBucket-&gt;pEdge == NULL)//若当前桶结点上没有链接边结点 &#123; currentBucket-&gt;pEdge = edge;//第一个边结点直接连接到对应的桶中 &#125; else if(edge-&gt;x &lt; currentBucket-&gt;pEdge-&gt;x)//比首结点小时 &#123; Edge *tempEdge = currentBucket-&gt;pEdge; currentBucket-&gt;pEdge = edge; edge-&gt;pNext = tempEdge; &#125; else //如果当前边已连有边结点 &#123; Edge *currentEdge = currentBucket-&gt;pEdge; while (currentEdge-&gt;pNext) &#123; if(currentEdge-&gt;pNext-&gt;x &gt;= edge-&gt;x &amp;&amp; currentEdge-&gt;x &lt; edge-&gt;x)//currentEdge的x比该边x小 且currentEdge下一个边比比该边x大时插入 &#123; Edge* tempEdge = currentEdge-&gt;pNext; currentEdge-&gt;pNext = edge; edge-&gt;pNext = tempEdge; return; &#125; currentEdge = currentEdge-&gt;pNext; &#125; //跳出循环时，说明edge-&gt;x比最后一个结点都大，所以放在最后 currentEdge-&gt;pNext = edge; edge-&gt;pNext = NULL; &#125;&#125; main.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * headBucket 是桶表头节点 * colorref 是填充颜色 */ void effectiveEdgeTableFillingAlgorithm(Bucket* headBucket ,COLORREF colorref, CDC *pDC)&#123; Edge *currentEdge = NULL, *tempEdge = NULL; Bucket* currentBucket = headBucket;//当前操作的桶，从第一个开始 Bucket* tempBucket = NULL; //访问所有桶结点 while(currentBucket-&gt;pNext) //for(currentBucket = headBucket; currentBucket != NULL; currentBucket = currentBucket-&gt;pNext) &#123; currentEdge = currentBucket-&gt;pEdge;//首先currentEdge指向当前扫描线的第一个边 //TODO: 以下是当前桶的绘图的代码。 bool in = true; //设置一个bool变量in，初始值为真，用于判断当前选择像素点是否在图形内部 tempEdge = currentEdge; while(tempEdge-&gt;pNext) &#123; if (in)//若在内部则绘图 &#123; for (double x = tempEdge-&gt;x; x &lt; tempEdge-&gt;pNext-&gt;x; x++) &#123; pDC-&gt;SetPixelV(x, currentBucket-&gt;scanLine, colorref); //Sleep(1); &#125; &#125; in = !in;//in取反 tempEdge = tempEdge-&gt;pNext; &#125; //TODO：以下是处理下个桶的代码。即将当前桶的边处理，得出下个桶的有效边，并插入下个桶中，同时释放当前桶的资源。 //遍历该桶 while(currentEdge) &#123; if(currentEdge-&gt;yMax &gt; currentBucket-&gt;scanLine + 1) //若满足加入条件,则将该结点进行修改并按顺序插入下一个桶 &#123; tempEdge = currentEdge; currentEdge = currentEdge-&gt;pNext; tempEdge-&gt;reUseEdge();//修改信息 Bucket::addEdge(currentBucket-&gt;pNext, tempEdge);//插入下个桶 &#125; else//否则释放该边的资源 &#123; tempEdge = currentEdge; currentEdge = currentEdge-&gt;pNext; //if(tempEdge != NULL)&#123; delete tempEdge; &#125; &#125; &#125; tempBucket = currentBucket; currentBucket = currentBucket-&gt;pNext; delete tempBucket; &#125;&#125;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>填充算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大类分流软件设计]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%A4%A7%E7%B1%BB%E5%88%86%E6%B5%81%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[大类分流基本思想是将6个文件模拟为一个按绩点顺序存放的队列，按排行和志愿顺序对队首元素分配专业。 将队首元素按志愿顺序映射为一个数组。对队首每个元素，如果当前志愿的专业人数达到人数限制，则判断下一个志愿。如果所有志愿人数都已满，则放入另一个未处理学生的队列中，等一轮分配完再处理。下面是具体算法。 已知n个学生，每个学生最多5个志愿。已知6个专业的人数限制。 将6个专业对应的文件读入6个存放学生信息的队列中； 设计数器 count.每个队首的绩点排名等于count弹出，弹出的元素根据志愿顺序映射到长度为6的数组对应的位置，count加上弹出的学生的人数；绩点排行小于count说明已分配过。则直接弹出 根据数组顺序来分配专业。如果当前志愿人数未满，写入结果数组，对应专业当前人数+1；人数已满则判断下一个志愿；所有志愿人数都满则排入未处理学生的队列。 最后处理未处理学生的队列，将他们分配到当前专业人数未满的专业即可。 需要注意注意的是第二部分，有可能有绩点排行相同的情况，所做的处理是把弹出的数组处理为一个链表数组。排名相同的学生按专业顺序插入到对应数组对应位置的链表中去。处理时仍然按次序处理即可。 这个算法的关键是注意到6个文件本身是排好序的，所以并没有将所有文件合并为一个有序序列，而是通过处理来模拟达到队列的效果。 处理的关键是每次“只处理6个文件的一行中绩点最高的学生的分配”，提高效率的关键是将绩点最高的学生的信息按志愿顺序映射存储再分配，因为是按志愿顺序处理。这样排名靠前的学生处理效率将大大提高，排名靠后的学生如果是根据自身情况选择合适的志愿，处理效率也会提高。 这儿是测试得到的结果 项目已经托管到 GitHub，戳我 。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown文本转为Html]]></title>
    <url>%2F2018%2F06%2F17%2FMarkdown%E6%96%87%E6%9C%AC%E8%BD%AC%E4%B8%BAHtml%2F</url>
    <content type="text"><![CDATA[利用Java语言，使用正则表达式借助编译原理的知识，制作出一个简易的将Markdown文本转为Html的程序。 网页中不方便代码展示及维护，故托管到Github，请移步 这里。 已经支持中文！~由于没有进行编码和解码处理，目前暂时只支持英文的转化。~ 支持的操作： 标题 分割线 有序列表和无序列表 斜体 加粗 删除线 标记 图片链接 网址链接和邮箱链接 不支持的操作： 引用片段 代码片段 表格 其他罕见功能 （持续更新）]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++实现简单计算器]]></title>
    <url>%2F2018%2F05%2F12%2FC-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[利用编译原理中递归下降的 语法分析 和 语义分析 ，使用 C++ 实现简单计算器。 文法如下： EXP -&gt; TERM {AlphaOP TERM} TERM -&gt; FACTOR {BetaOP FACTOR} FACTOR -&gt; (EXP) | number AlphaOP -&gt; + | - BetaOP -&gt; * | \ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;/* * EXP -&gt; TERM &#123;AlphaOP TERM&#125; * TERM -&gt; FACTOR &#123;BetaOP FACTOR&#125; * FACTOR -&gt; (EXP) | number * AlphaOP -&gt; + | - * BetaOP -&gt; * | \ */string inputExp;string::iterator ite;void handleError();void matchChar(char token);double matchDigit();double factor();double term();double expression();//错误处理void handleError() &#123; cerr &lt;&lt; "Error expression ! " + inputExp &lt;&lt;endl; exit(-1);&#125;//匹配字符void matchChar(char token) &#123; if (*ite == token) &#123; ite++; &#125; else &#123; handleError(); &#125;&#125;//匹配数字double matchDigit() &#123; string tempString = ""; while (isdigit(*ite)) &#123; tempString += *ite; ite++; &#125; istringstream iss(tempString); double temp; iss &gt;&gt; temp; return temp;&#125;double factor() &#123; double temp; if (isdigit(*ite)) &#123; temp = matchDigit(); &#125; else if (*ite == '(') &#123; matchChar('('); //处理负数 if(*ite == '-')&#123; ite++; temp = matchDigit() * (-1); &#125; else&#123; temp = expression(); &#125; matchChar(')'); &#125; else &#123; handleError(); &#125; return temp;&#125;double term() &#123; double temp = factor(); while (*ite == '*' || *ite == '/') &#123; if (*ite == '*') &#123; matchChar('*'); temp = temp * factor(); &#125; else &#123; matchChar('/'); temp = temp / factor(); &#125; &#125; return temp;&#125;double expression() &#123; double temp = term(); while (*ite == '+' || *ite == '-') &#123; if (*ite == '+') &#123; matchChar('+'); temp = temp + factor(); &#125; else &#123; matchChar('-'); temp = temp - factor(); &#125; &#125; return temp;&#125;int main() &#123; double result = 0; cout &lt;&lt; "请输入表达式："; cin &gt;&gt; inputExp; //加上空格防止迭代器溢出 inputExp += " "; ite = inputExp.begin(); while (*ite != inputExp.back()) &#123; result = expression(); &#125; cout &lt;&lt; result &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OperateFile-LAN-Java]]></title>
    <url>%2F2018%2F04%2F21%2FOperateFile-LAN-Java%2F</url>
    <content type="text"><![CDATA[利用Java RMI实现LAN（局域网）内服务端和客户端的文件传输及文件简单操作。 网页中不方便代码展示及维护，故托管到Github，请移步 [这里](https://github.com/CongLinDev/OperateFile-LAN-Java) 。 （持续更新） 预计于2018年6月份交付。 已交付。]]></content>
      <categories>
        <category>分布式技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表实现简单列车查询系统]]></title>
    <url>%2F2018%2F03%2F31%2F%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%88%97%E8%BD%A6%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[利用C++链表知识实现简单的列车查询系统。 设计目的综合运用链表知识解决实际问题的能力。 设计内容设计火车售票处的计算机系统，可以为客户提供下列各项服务： 查询列车信息：根据旅客提出的起始站和终点站名，或者列车车次，输出下列信息：列车车次、发车时刻、到达时刻、运行时间，以及每个途经站点的站名、到达时间、发车时间、运行里程等信息； 录入列车信息； 修改列车信息； 删除列车信息； 浏览所有列车信息； 其它必要功能。 设计要求 要求采用链表方式存储所有列车车次基本信息（如车次名称等），对于其中的每个列车车次，也采用链表方式存储各个途经站点信息； 能够支持查询、修改、增加、删除等信息； 如有时间，建议提供保存和打开功能，用户可以把所有信息保存到硬盘文件上，也可以从硬盘文件上读取信息； 界面友好。 代码实现station.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#pragma once#include &lt;string&gt;#include &lt;sstream&gt;using std::ostream;using std::string;using std::stringstream;//string类型的时间转换为int型分钟inline int timeToMinute(string aTime)&#123; string::iterator ite = aTime.begin(); int hour, minute; while(ite != aTime.end())&#123; if(*ite == ':')&#123; stringstream hourStream(string(aTime.begin(), ite)); hourStream &gt;&gt; hour; stringstream minuteStream(string(ite + 1, aTime.end())); minuteStream &gt;&gt; minute; return (hour * 60 + minute); &#125; ite++; &#125; return 0;&#125;class Station&#123; public: //有参构造函数 Station(string _stationName = "未命名站点", string _arrivalTime = "", string _leaveTime = "")&#123; stationName = _stationName; arrivalTime = _arrivalTime; leaveTime = _leaveTime; pNextStation = NULL; &#125; //复制构造函数 Station(Station &amp;aStation)&#123; this-&gt;stationName = aStation.stationName; this-&gt;arrivalTime = aStation.arrivalTime; this-&gt;leaveTime = aStation.leaveTime; this-&gt;pNextStation = aStation.pNextStation; &#125; //析构函数 ~Station()&#123;&#125; //重载输出运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Station &amp;aStation)&#123; os &lt;&lt; aStation.stationName &lt;&lt; '\t' &lt;&lt; aStation.arrivalTime &lt;&lt; '\t' &lt;&lt; aStation.leaveTime; return os; &#125; //计算此站出发到下站抵达经历的时间 int calTime()&#123; if(this-&gt;pNextStation == NULL)&#123; return 0; &#125; else &#123; int duringTime = timeToMinute(this-&gt;pNextStation-&gt;arrivalTime) - timeToMinute(this-&gt;leaveTime); return (duringTime &gt; 0) ? duringTime : duringTime + 24 * 60; &#125; &#125; string stationName; //站名 string arrivalTime; //到达时间 string leaveTime; //出发时间 Station* pNextStation; //下一个站点&#125;; train.h12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma once#include "station.h"#include &lt;vector&gt;using std::vector;class Train&#123; public: //构造函数 Train(string _trainName = "未命名列车")&#123; trainName = _trainName; stationNum = 0; headStation = NULL; pNextTrain = NULL; &#125; //析构函数 ~Train(); //添加站点 void insertStation(int locate, string _stationName = "未命名站点", string _arrivalTime = "未定义时间", string _leaveTime = "未定义时间"); //键盘添加站点 void keyboardInsertStation(); //删除站点 void deleteStation(); //改变站点信息 void changeStation(); //根据站点名称查询站点信息 void searchStationForName(); //打印该列车经过所有站点信息 void showAllStation(); //求列车经过站点个数 int getLength(); //重载运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Train &amp;aTrain); //更新运行里程和时间 void updateInfo(); string trainName; //列车车次 int stationNum; //站点个数 Station* headStation; //头站点 Train* pNextTrain; //下一列列车 //vector &lt;int&gt; mileag; //运行里程 vector &lt;int&gt; time; //运行时间&#125;; train.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include "train.h"#include &lt;iostream&gt;using std::cout;using std::endl;using std::cin;//更新运行里程和时间void Train::updateInfo()&#123; Station *myStation = this-&gt;headStation; //清空容器 this-&gt;time.clear(); while(myStation)&#123; //插入时间 this-&gt;time.push_back(myStation-&gt;calTime()); myStation = myStation-&gt;pNextStation; &#125;&#125;//重载运算符ostream &amp; operator&lt;&lt;(ostream &amp;os, const Train &amp;aTrain) &#123; Station *p = aTrain.headStation; while(p)&#123; os &lt;&lt; aTrain.trainName &lt;&lt; '\t' &lt;&lt; *p &lt;&lt; '\t' &lt;&lt; p-&gt;calTime() &lt;&lt;endl; p = p-&gt;pNextStation; &#125; return os;&#125;//求列车站点长度int Train::getLength()&#123; return this-&gt;stationNum;&#125;//添加站点void Train::insertStation(int locate, string _stationName, string _arrivalTime, string _leaveTime)&#123; if (locate &gt; this-&gt;stationNum + 1 || locate &lt; 1) &#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; &#125; else if (this-&gt;headStation != NULL &amp;&amp; locate &gt; 1) &#123; //new一个新站 Station* aStation = new Station(_stationName, _arrivalTime, _leaveTime); //将新站加入列车行程表中 Station* p = this-&gt;headStation; while (locate - 2) &#123; p = p-&gt;pNextStation; locate--; &#125; aStation-&gt;pNextStation = p-&gt;pNextStation; p-&gt;pNextStation = aStation; this-&gt;stationNum++; this-&gt;updateInfo(); cout &lt;&lt; "加入新站成功！" &lt;&lt; endl; &#125; else if (this-&gt;headStation != NULL &amp;&amp; locate == 1)&#123; //new一个新站 Station* aStation = new Station(_stationName, _arrivalTime, _leaveTime); //将新站加入列车行程表中 Station* p = this-&gt;headStation; this-&gt;headStation = aStation; aStation-&gt;pNextStation = p; this-&gt;stationNum++; this-&gt;updateInfo(); cout &lt;&lt; "加入新站成功！" &lt;&lt; endl; &#125; else &#123; //new一个新站 Station* aStation = new Station(_stationName, _arrivalTime, _leaveTime); //将新站加入列车行程表中 this-&gt;headStation = aStation; this-&gt;stationNum++; this-&gt;updateInfo(); cout &lt;&lt; "加入新站成功！" &lt;&lt; endl; &#125;&#125;//键盘增加站点void Train::keyboardInsertStation()&#123; int locate; cout &lt;&lt; "请输入插入的位置："; cin &gt;&gt; locate; string _stationName, _arrivalTime, _leaveTime; cout &lt;&lt; "请分别输入 站点名称 到达时间 出发时间 ：" &lt;&lt; endl; cin &gt;&gt; _stationName &gt;&gt; _arrivalTime &gt;&gt; _leaveTime; this-&gt;insertStation(locate, _stationName, _arrivalTime, _leaveTime);&#125;//删除站点void Train::deleteStation()&#123; int locate; cout &lt;&lt; "请输入插入的位置："; cin &gt;&gt; locate; if(locate &gt; this-&gt;stationNum || locate &lt; 1)&#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; &#125;else if(this-&gt;headStation != NULL &amp;&amp; locate &gt; 1)&#123; Station* p = this-&gt;headStation; while(locate - 2)&#123; //到达第i-1个结点，p-&gt;pNextStation为欲删除的结点的指针 p = p-&gt;pNextStation; locate--; &#125; Station* q = p-&gt;pNextStation; p-&gt;pNextStation = p-&gt;pNextStation-&gt;pNextStation; delete q; this-&gt;stationNum--; this-&gt;updateInfo(); cout &lt;&lt; "删除站点完成！" &lt;&lt; endl; &#125; else if(this-&gt;headStation != NULL &amp;&amp; locate == 1)&#123; Station* p = this-&gt;headStation; this-&gt;headStation = p-&gt;pNextStation; delete p; this-&gt;stationNum--; this-&gt;updateInfo(); cout &lt;&lt; "删除站点完成！" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "列车站台为空！" &lt;&lt; endl; &#125;&#125;//析构函数Train::~Train()&#123; if(this-&gt;headStation == NULL)&#123; &#125; else&#123; Station* p = this-&gt;headStation; Station* q; while (p)&#123; q = p; p = p-&gt;pNextStation; delete q; &#125; &#125;&#125;//改变站点信息void Train::changeStation()&#123; int locate; cout &lt;&lt; "请输入需要改变站台所在的位置："; cin &gt;&gt; locate; if(locate &gt; this-&gt;stationNum || locate &lt; 1)&#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; return; &#125;else&#123; Station* p = this-&gt;headStation; while(locate - 1)&#123; p = p-&gt;pNextStation; locate--; &#125; cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; "1. 站点名称\n2. 列车到达时间\n3. 列车出发时间\n"; cout &lt;&lt; "站点已找到，请选择改变的信息："; int choose; string changeValue; cin &gt;&gt; choose; switch(choose)&#123; case 1: cout &lt;&lt; "请输入新的站名："; cin &gt;&gt; changeValue; p-&gt;stationName = changeValue; cout &lt;&lt; "修改完成！" &lt;&lt; endl; break; case 2: cout &lt;&lt; "请输入新的到达时间："; cin &gt;&gt; changeValue; p-&gt;arrivalTime = changeValue; cout &lt;&lt; "修改完成！" &lt;&lt; endl; this-&gt;updateInfo(); break; case 3: cout &lt;&lt; "请输入新的出发时间："; cin &gt;&gt; changeValue; p-&gt;leaveTime = changeValue; cout &lt;&lt; "修改完成！" &lt;&lt; endl; this-&gt;updateInfo(); break; default: cout &lt;&lt; "未更改数据，请输入正确的数字！" &lt;&lt; endl; &#125; &#125;&#125;//根据站点名称查询站点信息void Train::searchStationForName() &#123; string _stationName; cout &lt;&lt; "请输入要查询的站名：" ; cin &gt;&gt; _stationName; Station* p = this-&gt;headStation; if (p == NULL) &#123; cout &lt;&lt; "行程表为空！" &lt;&lt; endl; &#125; int count = 1; //计数器 while (p) &#123; if (p-&gt;stationName == _stationName) &#123; cout &lt;&lt; "该站点为行程表第" &lt;&lt; count &lt;&lt; "个站点\n站点名称为：" &lt;&lt; p-&gt;stationName &lt;&lt; "\n列车到达时间为：" &lt;&lt; p-&gt;arrivalTime &lt;&lt; "\n列车出发时间为：" &lt;&lt; p-&gt;leaveTime &lt;&lt; endl; &#125; count++; p = p-&gt;pNextStation; &#125; cout &lt;&lt; "未找到该站点的信息！" &lt;&lt; endl;&#125;//打印该列车所有站点void Train::showAllStation() &#123; cout &lt;&lt; this-&gt;trainName &lt;&lt; " 的行程表为：" &lt;&lt; endl; cout &lt;&lt; "列车信息 站点名称 到站时间 出发时间 到达下站所需时间(min)" &lt;&lt; endl; cout &lt;&lt; *this &lt;&lt; endl;&#125; schedule.h12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma once#include "train.h"class Schedule&#123; public: //构造函数 Schedule(string _scheduleName = "未命名时刻表")&#123; scheduleName = _scheduleName; trainNum = 0; headTrain = NULL; &#125; //析构函数 ~Schedule(); //添加列车 Train* insertTrain(int locate, string _trainName = "未命名列车"); //键盘添加站点 void keyboardInsertTrain(); //文本添加站点 void txtInsertTrain(string filename); //文本输出站点 void scheduleToTxt(string filename); //删除列车 void deleteTrain(); //改变列车站点信息 void changeTrainStation(); //改变列车名称 void changeTrainName(); //根据列车名称查询站点信息 Train* searchTrainForName(); //打印所有列车经过所有站点信息 void showAllTrain(); //求列车个数 int getLength(); //操作菜单 void operateTheSchedule(); //重载运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Schedule &amp;aSchedule); private: string scheduleName; //列车车次 int trainNum; //站点个数 Train* headTrain; //头站点&#125;; schedule.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#include "schedule.h"#include &lt;iostream&gt;#include &lt;fstream&gt;using std::cout;using std::endl;using std::cin;using std::ifstream;using std::ofstream;//重载运算符ostream &amp; operator&lt;&lt;(ostream &amp;os, const Schedule &amp;aSchedule) &#123; Train *p = aSchedule.headTrain; while (p) &#123; os &lt;&lt; *p; p = p-&gt;pNextTrain; &#125; return os;&#125;//求列车长度int Schedule::getLength()&#123; return this-&gt;trainNum;&#125;//添加列车Train* Schedule::insertTrain(int locate, string _trainName)&#123; if (locate &gt; this-&gt;trainNum + 1 || locate &lt; 1) &#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; return NULL; &#125; else if (this-&gt;headTrain != NULL &amp;&amp; locate &gt; 1) &#123; //new一个新列车 Train* aTrain = new Train(_trainName); //将新列车加入列车行程表中 Train* p = this-&gt;headTrain; while (locate - 2) &#123; p = p-&gt;pNextTrain; locate--; &#125; aTrain-&gt;pNextTrain = p-&gt;pNextTrain; p-&gt;pNextTrain = aTrain; this-&gt;trainNum++; cout &lt;&lt; "加入新列车成功！" &lt;&lt; endl; return aTrain; &#125; else if(this-&gt;headTrain != NULL &amp;&amp; locate == 1)&#123; //new一个新列车 Train* aTrain = new Train(_trainName); //将新列车加入列车行程表中 Train* p = this-&gt;headTrain; this-&gt;headTrain = aTrain; aTrain-&gt;pNextTrain = p; this-&gt;trainNum++; cout &lt;&lt; "加入新列车成功！" &lt;&lt; endl; return aTrain; &#125; else &#123; //new一个新列车 Train* aTrain = new Train(_trainName); //将新站加入列车行程表中 this-&gt;headTrain = aTrain; this-&gt;trainNum++; cout &lt;&lt; "加入新列车成功！" &lt;&lt; endl; return aTrain; &#125;&#125;//键盘增加列车void Schedule::keyboardInsertTrain()&#123; int locate; cout &lt;&lt; "请输入插入的位置："; cin &gt;&gt; locate; string _trainName; cout &lt;&lt; "请输入列车名称：" ; cin &gt;&gt; _trainName; this-&gt;insertTrain(locate, _trainName);&#125;//文本添加站点void Schedule::txtInsertTrain(string filename)&#123; ifstream infile; infile.open(filename + ".txt"); if(!infile)&#123; cout &lt;&lt; "ERROR：打开 " &lt;&lt; filename &lt;&lt; ".txt 文件失败" &lt;&lt; endl; return; &#125; //_lastTrainName用于优化查找速度,但不可用于多次文本输入内存 string _trainName, _stationName, _arrivalTime, _leaveTime, _lastTrainName; if(this-&gt;headTrain == NULL)&#123; _lastTrainName = ""; &#125;else&#123; _lastTrainName = this-&gt;headTrain-&gt;trainName; &#125; while(infile &gt;&gt; _trainName&gt;&gt; _stationName&gt;&gt;_arrivalTime&gt;&gt;_leaveTime)&#123; if(_trainName == _lastTrainName)&#123; Train *p = this-&gt;headTrain; while (p) &#123; if (p-&gt;trainName == _trainName) &#123; p-&gt;insertStation(p-&gt;stationNum+1, _stationName, _arrivalTime, _leaveTime); break; &#125; p = p-&gt;pNextTrain; &#125; &#125; else &#123; Train *p = this-&gt;insertTrain(this-&gt;trainNum+1, _trainName); p-&gt;insertStation(p-&gt;stationNum+1, _stationName, _arrivalTime, _leaveTime); _lastTrainName = _trainName; &#125; &#125; infile.close();&#125;//文本输出信息void Schedule::scheduleToTxt(string filename)&#123; ofstream outfile; outfile.open(filename + ".txt"); if (!outfile) &#123; cout &lt;&lt; "ERROR：打开 " &lt;&lt; filename &lt;&lt; ".txt 文件失败" &lt;&lt; endl; return; &#125; outfile &lt;&lt; *this; outfile.close();&#125;//删除站点void Schedule::deleteTrain()&#123; int locate; cout &lt;&lt; "请输入删除的位置："; cin &gt;&gt; locate; if(locate &gt; this-&gt;trainNum || locate &lt; 1)&#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; &#125;else if(this-&gt;trainNum != NULL &amp;&amp; locate &gt; 1)&#123; Train* p = this-&gt;headTrain; while(locate - 2)&#123; //到达第i-1个结点，p-&gt;pNextTrain为欲删除的结点的指针 p = p-&gt;pNextTrain; locate--; &#125; Train* q = p-&gt;pNextTrain; p-&gt;pNextTrain = p-&gt;pNextTrain-&gt;pNextTrain; //删除列车的站点 while(q-&gt;stationNum)&#123; Station* delSta; delSta = q-&gt;headStation; q-&gt;headStation = q-&gt;headStation-&gt;pNextStation; delete delSta; q-&gt;stationNum--; &#125; //删除列车 delete q; this-&gt;trainNum--; cout &lt;&lt; "删除列车完成！" &lt;&lt; endl; &#125; else if (this-&gt;trainNum != NULL &amp;&amp; locate == 1)&#123; Train* p = this-&gt;headTrain; this-&gt;headTrain = p-&gt;pNextTrain; //删除列车的站点 while (p-&gt;stationNum) &#123; Station* delSta; delSta = p-&gt;headStation; p-&gt;headStation = p-&gt;headStation-&gt;pNextStation; delete delSta; p-&gt;stationNum--; &#125; //删除列车 delete p; this-&gt;trainNum--; cout &lt;&lt; "删除列车完成！" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "行程表为空！" &lt;&lt; endl; &#125;&#125;//析构函数Schedule::~Schedule()&#123; if (this-&gt;headTrain == NULL) &#123; &#125;else &#123; Train* p = this-&gt;headTrain; Train* q; while (p) &#123; q = p; p = p-&gt;pNextTrain; delete q; &#125; &#125;&#125;//改变列车信息void Schedule::changeTrainStation()&#123; Train* p = this-&gt;searchTrainForName(); if(p != NULL)&#123; while (1) &#123; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; cout &lt;&lt; " * 列车查询系统子菜单 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 您现在正在操作 " &lt;&lt; p-&gt;trainName &lt;&lt; " 列车 *" &lt;&lt; endl; cout &lt;&lt; " * 请输入对应功能的数字完成操作 *" &lt;&lt; endl; cout &lt;&lt; " * 1.添加站点信息 *" &lt;&lt; endl; cout &lt;&lt; " * 2.删除站点信息 *" &lt;&lt; endl; cout &lt;&lt; " * 3.修改站点信息 *" &lt;&lt; endl; cout &lt;&lt; " * 0.退出子菜单 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 列车 "&lt;&lt; p-&gt;trainName &lt;&lt; " 现有站台 "&lt;&lt;p-&gt;getLength() &lt;&lt;" 个 *" &lt;&lt; endl; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; int choice; cout &lt;&lt; "请输入您的选项："; cin &gt;&gt; choice; switch (choice) &#123; case 1: p-&gt;keyboardInsertStation(); break; case 2: p-&gt;deleteStation(); break; case 3: p-&gt;changeStation(); break; case 0: return; default: cout &lt;&lt; "输入选项非法！请重新输入！" &lt;&lt; endl; break; &#125; &#125; &#125;&#125;//查询列车具体信息Train* Schedule::searchTrainForName() &#123; string _trainName; cout &lt;&lt; "请输入要查询的列车名：" ; cin &gt;&gt; _trainName; Train* p = this-&gt;headTrain; if (p == NULL) &#123; cout &lt;&lt; "行程表为空！" &lt;&lt; endl; return p; &#125; int count = 1; //计数器 while (p) &#123; if (p-&gt;trainName == _trainName) &#123; cout &lt;&lt; *p &lt;&lt; endl; return p; &#125; count++; p = p-&gt;pNextTrain; &#125; cout &lt;&lt; "未找到该列车的信息！" &lt;&lt; endl; return p;&#125;//改变列车名称void Schedule::changeTrainName()&#123; Train* p = this-&gt;searchTrainForName(); if (p != NULL) &#123; cout &lt;&lt; "列车已找到，请输入新的列车名："; string _trainName; cin &gt;&gt; _trainName; p-&gt;trainName = _trainName; cout &lt;&lt; "修改成功！" &lt;&lt; endl; &#125;&#125;//打印所有列车所有站点void Schedule::showAllTrain() &#123; cout &lt;&lt; this-&gt;scheduleName &lt;&lt; " 的行程表为：" &lt;&lt; endl; cout &lt;&lt; "列车信息\t站点名称\t到站时间\t出发时间" &lt;&lt; endl; cout &lt;&lt; *this;&#125;//操作菜单void Schedule::operateTheSchedule() &#123; while (true) &#123; int choice; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; cout &lt;&lt; " * 列车查询系统 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 请输入对应功能的数字完成操作 *" &lt;&lt; endl; cout &lt;&lt; " * 1.键盘添加列车信息 *" &lt;&lt; endl; cout &lt;&lt; " * 2.文本添加列车信息 *" &lt;&lt; endl; cout &lt;&lt; " * 3.删除列车信息 *" &lt;&lt; endl; cout &lt;&lt; " * 4.修改列车名称信息 *" &lt;&lt; endl; cout &lt;&lt; " * 5.修改列车站点具体信息 *" &lt;&lt; endl; cout &lt;&lt; " * 6.输出行程表信息 *" &lt;&lt; endl; cout &lt;&lt; " * 0.退出系统 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 目前共有" &lt;&lt; this-&gt;getLength() &lt;&lt; "辆列车 *" &lt;&lt; endl; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; cout &lt;&lt; "请输入您的选项："; cin &gt;&gt; choice; switch (choice) &#123; case 1: this-&gt;keyboardInsertTrain(); break; case 2: &#123; cout &lt;&lt; "请输入要打开的文件名："; string filename; cin &gt;&gt; filename; this-&gt;txtInsertTrain(filename); break; &#125; case 3: this-&gt;deleteTrain(); break; case 4: this-&gt;changeTrainName(); break; case 5: this-&gt;changeTrainStation(); break; case 6: this-&gt;showAllTrain(); break; case 0: &#123; cout &lt;&lt; "您需要保存该行程表吗？(Y/N)\t"; char c; cin &gt;&gt; c; if (c == 'Y' || c == 'y') &#123; cout &lt;&lt; "请输入文件名："; string filename; cin &gt;&gt; filename; this-&gt;scheduleToTxt(filename); return; &#125; return; &#125; default: cout &lt;&lt; "输入选项非法！请重新输入！" &lt;&lt; endl; break; &#125; &#125;&#125; main.cpp12345678#include "schedule.h"int main()&#123; Schedule mySchedule("我的行程表"); mySchedule.operateTheSchedule(); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++文件在Html的高亮处理]]></title>
    <url>%2F2018%2F03%2F17%2FC-%E6%96%87%E4%BB%B6%E5%9C%A8Html%E7%9A%84%E9%AB%98%E4%BA%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[编译原理最基础的问题便是词法分析器了。下面是我使用C++语言利用迭代器实现的将C++源码转为HTML文件，并实现HighLight。 （长期更新，直至成熟）（较为成熟，不再更新） 版本记录 V-0.2.1 (20180326) 添加对制表符（\t）的支持。 V-0.2.0 (20180325) 优化搜索算法。 V-0.1.4 (20180324) 支持显示代码行数。 V-0.1.3 (20180323) 添加了对多行注释的高亮显示。 V-0.1.2 (20180322) 添加了对单行注释（//）的高亮显示。 V-0.1.1 (20180318) 完善了部分功能，添加了对部分字符（如&lt;、&gt;、&amp;、”、）的支持以及头文件行的高亮显示。 V-0.1.0 (20180317) 只实现了大致功能，对字符（如&lt;、&gt;等）处理还未完善，其次准确的说，这是按照词读入，并不是字母，当然利用迭代器同理可以实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;//63个保留字const int RESERVEWORDNUM = 63;const string reserveWord[RESERVEWORDNUM] = &#123; "asm", "auto", "bool", "break", "catch", "case", "char", "class", "const", "const_cast", "continue", "default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern", "false", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable", "namespace", "new", "operator", "private", "protected", "public", "register", "register_cast", "return", "short", "signed", "sizeof", "static", "static_cast", "struct", "switch", "template", "this", "throw", "true", "try", "typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void", "wchar_t", "volatile", "while"&#125;;//动态数组vector&lt;string&gt; reserveWordVector(reserveWord, reserveWord + RESERVEWORDNUM);//检测是否是保留字bool isReserveWord(string &amp;word)&#123; vector&lt;string&gt;::iterator itV; itV = find(reserveWordVector.begin(), reserveWordVector.end(), word); if ( itV != reserveWordVector.end() )&#123; return true ; &#125; else &#123; return false ; &#125;&#125;void translate(string filename)&#123; ifstream infile; //输入流对象 infile.open(filename + ".cpp"); ofstream outfile; //输出流对象 outfile.open(filename + ".html"); int line = 0; //记录cpp文件行数 if (!infile &amp;&amp; !outfile)&#123; cout &lt;&lt; "ERROR：打开文件失败！" &lt;&lt; endl; return ; &#125; string aLine; //存放cpp文件一行代码 string::iterator lineIte; //定义行迭代器 //读取一行代码 while (getline(infile, aLine)) &#123; line++; //更新行数 aLine += " "; //每行后添加空白防止迭代器溢出 string aHtmlLine = ""; //html的一行 lineIte = aLine.begin(); //初始化行迭代器指向行首位置 //对该行进行分割，对分割出的字进行检测 while (lineIte != aLine.end())&#123; string word = ""; //存放一个单词 //行迭代器遇到空格或换行符号时停止并截取单词 while (*lineIte != ' ' &amp;&amp; *lineIte != aLine.back())&#123; //针对html语法，对字符串的处理 if (*lineIte == '&lt;') &#123; word += "&amp;lt;"; &#125; else if (*lineIte == '&gt;') &#123; word += "&amp;gt;"; &#125; else if (*lineIte == '&amp;') &#123; word += "&amp;amp;"; &#125; else if (*lineIte == '\"') &#123; word += "&amp;quot;"; &#125; else if (*lineIte == '\t') &#123; aHtmlLine += " &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "; &#125; //处理缩进问题 else &#123; word += *lineIte; &#125; lineIte++; &#125; //检测单行注释 if (*word.begin() == '/' &amp;&amp; *(word.begin() + 1) == '/') &#123; word = "&lt;font color=\"yellow\"&gt;&lt;b&gt;" + word + "&lt;/b&gt;&lt;/font&gt;"; //注释为黄色 &#125; //检测多行注释 if (*word.begin() == '/' &amp;&amp; *(word.begin() + 1) == '*') &#123; word = "&lt;font color=\"yellow\"&gt;&lt;b&gt;" + word ; //注释为黄色 &#125; if (*word.rbegin() == '/' &amp;&amp; *(word.rbegin() + 1) == '*') &#123; word = word + "&lt;/b&gt;&lt;/font&gt;"; &#125; //检测是否是保留字 if (isReserveWord(word)) &#123; aHtmlLine += "&lt;font color=\"blue\"&gt;&lt;b&gt;" + word + "&lt;/b&gt;&lt;/font&gt;"; //加粗保留字并设置为蓝色 &#125; else &#123; aHtmlLine += word; //其他字不做处理 &#125; if (*lineIte == ' ') &#123; lineIte++; aHtmlLine += " "; &#125; &#125; //检测是否是头文件行 if (*aLine.begin() == '#') &#123; aHtmlLine = "&lt;font color=\"green\"&gt;&lt;b&gt;" + aHtmlLine + "&lt;/b&gt;&lt;/font&gt;"; //头文件行变绿色 &#125; outfile &lt;&lt; "&lt;font color=\"black\"&gt;&lt;b&gt;" &lt;&lt; setw(4) &lt;&lt; setfill('0') &lt;&lt; line &lt;&lt; "&lt;/b&gt;&lt;/font&gt;&amp;sdot; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;" + aHtmlLine + "&lt;br/&gt;" &lt;&lt; endl; //写入.html文件 &#125; infile.close(); //关闭文件流 outfile.close(); //关闭文件流 cout &lt;&lt; "转换成功！" &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; "请输入您要转换的cpp文件："; string cppFileName; cin &gt;&gt; cppFileName; translate(cppFileName); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扔鸡蛋问题]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Google有一道扔鸡蛋的面试题目： You work in a 100 floor building and you get 2 identical eggs.You need to figure out the highest floor an egg can be dropped without breaking.The question is how many throws you need to make.Find an algorithm that is minimizing number of throws in the worst-case scenario. 这道题的意思大致如下： 情景假设1、你在一个 100层高的大楼里； 2、你有 2个一模一样的鸡蛋； 任务1、弄清楚： 鸡蛋最高可以从几层楼扔下去而不会被摔坏； 2、弄清楚你需要扔几次； 3、 提出一个算法，找出在最坏情况下，扔出鸡蛋而不把鸡蛋摔坏的最少次数； 假设首先，在解题之前，我们要做好几个简单的假设： 2个鸡蛋的脆弱程度是一样的。 如果鸡蛋从N楼扔下来没有碎，那么它从小于N楼扔下来，也不会碎 如果鸡蛋从N楼扔下来碎了，那么它从大于N楼扔下来，也一定会碎 一颗扔出去但没有碎的鸡蛋，可以继续被用于试验。 碎了的鸡蛋将无法再继续试验。 有了这些假设之后，我们就可以解题了。 其实解决这道问题的方法有很多，在此列举一些： 最简单解法最简单的一个方法，就是 将鸡蛋从第一层开始，逐层扔出，看它在哪一层会摔碎。 这个方法虽然可靠，但它可能需要进行很多次尝试。比如，在最差的情况下，它需要尝试的次数是100次。 需要注意的一点是，当你只有一颗鸡蛋时，这个算法是唯一可靠的方法。 所以一旦你打碎了第一颗鸡蛋，手里只剩下最后一颗的时候，你就要开始运用这个算法。 最直观解法这个方法重点，是要 利用好第一颗鸡蛋，最大效率地把100层高楼划分成N个更小数目的区间。 一个比较直观和流行的答案是， 将鸡蛋从【要检查的楼层* 1/N】层开始扔下去，逐层检查。 例如，当N=3时，我们就将第一颗鸡蛋从100*1/3 ≈ 33层楼扔出： ► 如果它破损了，我们就接着用第二颗鸡蛋检验32层楼及以下。 ► 如果它没破损，我们就继续将同一颗鸡蛋从33 + (67 * 1/3) = 55层楼扔出，如果它破了，我们就用第二颗鸡蛋，检验34层 - 55层 …… 当N = 3时，最坏的情况是max(33, 24, …) = 33层。 按照这个思路，再通过dynamic programming，我们就可以找到一个完美的N，来最优化鸡蛋的投掷次数了。 这个解法在面试中还是很有&quot;价值&quot;的，毕竟它能向面试官展现求职者的编程思维。但它还不是最佳解法。 最优解在理解最佳解法之前，我们需要理解以下这个equilibrium（均衡状态）： 这个均衡状态计算的是在最坏情境下，所需的扔鸡蛋次数。这里，F(n)指的是楼层，是我们扔第一个鸡蛋后的下一层。 假如我们引入以下变量： 那么刚刚的equilibrium就变成这样： 当这个函数里的所有参数都相等时，就是我们的最优解。 那么我们如何做到呢？ 从末尾开始看，最后的D(n)将会变成1，因为最终我们将会到达一个点 —— 就是只剩下一层楼可以扔第一颗鸡蛋。 因此，D(n-1)应该等于2。 我们接着会发现，第一颗鸡蛋最终应该是从第99层楼扔出，之前是从99-2=97层，再往前则是97-3=94层，90, 85, 79, 72, 64, 55, 45, 34, 22，然后是第9层。 这就是一个最优解！ 这样一来，我们就得出了答案： 在最坏的情况下，我们需要的扔鸡蛋的最少次数，是14次 （最小的差别在于13，但是我们还需要在第9层额外扔一次）。 检查现在就到了检验我们的解法是否正确的时候了。我们可以编写一个简单的Kotlin程序来检验答案。首先，我们需要解释一下，如何在某些决策中，计算扔鸡蛋次数。当有2层或更少的楼层时，我们需要按照剩余的楼层数，来决定扔鸡蛋的次数。 否则，我们应该调用以下均衡函数： 我们在这里使用了bestMaxThrows函数。这是一个假设的函数，它会返回一个投掷次数的数值，并假设接下来的一系列决策是完美的。 我们是这样定义它的： 同样，我们把&quot;计算下一层最优解&quot;的任务，交给了bestNextStep 函数。这个函数很好的为我们指明了下一步的方向。我们可以这样简单地定义它：当只有二层或更少的楼层待检验时，我们会从第一层扔出鸡蛋。否则，我们需要检查所有备选项，然后找到最优解。 下面是具体执行步骤： 需要注意的是，这个方程用了maxThrows函数，因此会涉及到recurrence （循环）。 但这并不成问题，因为当bestNextStep调用maxThrows时，它始终会使用比floorLeft更小的值调用它（因为nextFloor总是大于0）。 在我们使用它之前，我们需要添加一些缓冲，从而加速计算： 首先，我们可以检查它是否返回与我们计算结果相同的结果： 结果是14 —— 这个结果看上去还不错，我们接着检查之后的几个步骤： Result9, 22, 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, 100, 跟我们计算的结果是一致的! Bigger picture以上分享的这个算法，其实还可以解决许多其他类似的问题。 比如，我们可以把原题的提问改改，改成计算最随机情况下的扔鸡蛋次数。我们还可以看看，当建筑物的高度有变化时，得出的结果是否也会跟着变化。 下图很好地回答了以上问题：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2018%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;2018年2月26日，基于Hexo框架并托管在GitHub服务器上，我建立了第一个自己的博客网站 (https://conglindev.github.io/)&ensp;&ensp;&ensp;&ensp;虽然功能不完善，但是具有了博客的基本的功能。以后我会尽量完善和美化这个网站的。 Hello world!]]></content>
  </entry>
</search>

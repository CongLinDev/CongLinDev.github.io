<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[抓取简单的Pcap文件并读出信息]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%8A%93%E5%8F%96%E7%AE%80%E5%8D%95%E7%9A%84Pcap%E6%96%87%E4%BB%B6%E5%B9%B6%E8%AF%BB%E5%87%BA%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[以下开发均基于Linux平台，以Ubuntu为例进行讲解，具体源码移步这里。 抓取Pcap文件笔者使用libpcap库（libpcap是unix/linux平台下的网络数据包捕获函数包）进行抓包。 安装libpcap库 Libpcap下载。 解压下载的压缩包 tar -zxvf filename.tar.gz （filename是下载的文件名） 配置生成makefile文件。进入解压的文件夹，执行 ./configure。这里可能会提示缺少flex，使用sudo apt-get install flex即可。 执行make。这里可能会提示缺少yacc，使用sudo apt-get install yacc即可。 执行sudo make install。 使用库函数抓包 pcap_lookupdev()：函数用于查找网络设备，返回可被 pcap_open_live() 函数调用的网络设备名指针。 pcap_lookupnet()：函数获得指定网络设备的网络号和掩码。 pcap_open_live()： 函数用于打开网络设备，并且返回用于捕获网络数据包的数据包捕获描述字。对于此网络设备的操作都要基于此网络设备描述字。 pcap_compile()： 函数用于将用户制定的过滤策略编译到过滤程序中。 pcap_setfilter()：函数用于设置过滤器。 pcap_loop()：函数 pcap_dispatch() 函数用于捕获数据包，捕获后还可以进行处理，此外 pcap_next() 和 pcap_next_ex() 两个函数也可以用来捕获数据包。 pcap_close()：函数用于关闭网络设备，释放资源。 pcap_dump_open用于打开保存的文件 pcap_dump用于输出数据到文件。 分析Pcap文件这里给出用于读取Pcap文件的结构体。读者可以从中看出Pcap文件的结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213/* Wireshark File Formate +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | PCAP File Header | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | PCAP Package Header | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Ethernet frame header | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | IP Header | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SCTP Package | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/typedef unsigned char _1Byte;typedef unsigned short _2Byte;typedef unsigned int _4Byte;#define PCAP_FILE_HEADER_SIZE 24 //24个字节#define PACKET_HEADER_SIZE 16 //16个字节#define MAC_HEADER_SIZE 14 //14个字节#define IP_HEADER_SIZE 20 //20个字节#define ICMP_HEADER_SIZE 8 //8个字节#define TCP_HEADER_SIZE 20 //20个字节#define UDP_HEADER_SIZE 8 //8个字节/* PCAP File Header 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magic Number(0xA1B2C3D4) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magjor Version(0x02) | Minor Version(0x04) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Time Zone(0) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Time Stamp Accuracy(0) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Snapshot Length(0xFFFF) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Link Layer Type(0x01) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/struct PcapFileHeader&#123; _4Byte magic; //4Byte：标记文件开始，并用来识别文件自己和字节顺序。 _2Byte majorVersion; //2Byte： 当前文件主要的版本号，一般为 0x0200 _2Byte minorVersion; //2Byte： 当前文件次要的版本号，一般为 0x0400 _4Byte timezone; //4Byte：当地的标准时间，如果用的是GMT则全零 _4Byte sigFlags; //4Byte：时间戳的精度 _4Byte snapLen; //4Byte：最大的存储长度 _4Byte linkType; //4Byte：链路类型&#125;;/* Packet Header 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Seconds | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Microseconds | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | CapLen | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Len | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/struct PacketHeader&#123; _4Byte seconds; //4Byte 秒计时,被捕获时间的高位，单位是seconds _4Byte microseconds; //4Byte 微秒计时,被捕获时间的低位，单位是microseconds _4Byte capLen; //4Byte 当前数据区的长度，即抓取到的数据帧长度，不包括Packet Header本身的长度，单位是 Byte _4Byte len; //4Byte 离线数据长度：网络中实际数据帧的长度，一般不大于caplen，多数情况下和Caplen数值相等&#125;;/* IP Header 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Version| IHL |Type of Service| Total Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Identification |Flags| Fragment Offset | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Time to Live | Protocol | Header Checksum | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Destination Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Options | Padding | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/struct IPHeader&#123; /*----------第一行-------------------*/ union//共一个字节 &#123; _1Byte version;//版本号 _1Byte headerLength;//包头长度,指明IPv4协议包头长度的字节数包含多少个32位 &#125;; _1Byte serviceType;//区分服务 _2Byte totalLength;//总长度 /*----------第二行-------------------*/ _2Byte identification;//标识 union &#123; _2Byte flags;//标志,当封包在传输过程中进行最佳组合时使用的3个bit的识别记号 _2Byte fragmentOffset;//片偏移 &#125;; /*----------第三行-------------------*/ _1Byte timeToLive;//生存时间 _1Byte protocol;//协议 _2Byte headerChecksum;//首部检验和 /*----------第四行-------------------*/ _4Byte sourceAddress;//源地址 /*----------第五行-------------------*/ _4Byte destinationAddress;//目标地址&#125;;//MAC帧信息struct MACHeader&#123; _1Byte destinationAddress[6]; _1Byte sourceAddress[6]; _2Byte type;&#125;;/* ICMPHeader 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | type | code | Header Checksum | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Identification | serial | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/struct ICMPHeader &#123; _1Byte type; //类型 _1Byte code; //代码 _2Byte headerChecksum;//首部检验和 _2Byte identification;//标识 _2Byte serial;//序列号&#125;;/* TCP Header 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source port | Destination port | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Serial | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Acknowledgement Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |DataOffset|Reserve|u|a|p|r|s|f| Window | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Checksum | Urgent Pointer | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Options | Padding | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/struct TCPHeader&#123; _2Byte sourcePort;//源端口 _2Byte destinationPort;//目的端口 _4Byte serial;//序号 _4Byte acknowledgementNumber;//确认号 union&#123;//共2个字节 _2Byte dataOffset;//数据偏移 _2Byte reserve;//保留 _2Byte urg;//紧急 _2Byte ack;//确认 _2Byte psh;//推送 _2Byte rst;//复位 _2Byte syn;//同步 _2Byte fin;//终止 &#125;; _2Byte window;//窗口 _2Byte checksum;//检验和 _2Byte urgentpointer;//紧急指针&#125;;struct UDPHeader&#123; _2Byte sourcePort;//源端口 _2Byte destinationPort;//目的端口 _2Byte length;//长度 _2Byte checksum;//检验和&#125;; 分析的过程即是个读取文件的过程，在此不再赘述。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux--实现简单的ls功能]]></title>
    <url>%2F2018%2F11%2F18%2FLinux-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84ls%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[利用Linux C实现简单的ls功能，其中包括： -a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)。 -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出。 -R 若目录下有文件，则以下之文件亦皆递归依序列出。 -d 显示目录名称而非其内容。 -i 显示文件和目录的inode编号。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//ls_command.cpp#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;dirent.h&gt;#include &lt;stdbool.h&gt;#define PARAM_TYPE_NUM 6//参数种类#define DESTINATION_PARAM 0#define a_PARAM 1#define d_PARAM 2#define i_PARAM 3#define l_PARAM 4#define R_PARAM 5void handle_params(int argc, char* argv[], bool params[], char* optstring);void handle_ls_command(bool params[], char* argv[]);void printDir(char *dir, int depth, bool params[]);void handle_params(int argc, char* argv[], bool params[], char* optstring)&#123; int opt; while((opt = getopt(argc, argv, optstring)) != -1)&#123; switch(opt)&#123; case 'a': params[a_PARAM] = true; break; case 'd': params[d_PARAM] = true; break; case 'i': params[i_PARAM] = true; break; case 'l': params[l_PARAM] = true; break; case 'R': params[R_PARAM] = true; break; case '?': printf("ls: unknown option: %c\n", optopt); optind--; break; default: break; &#125; &#125; if(optind &lt; argc)&#123; params[DESTINATION_PARAM] = true; &#125;&#125;void handle_ls_command(bool params[], char* argv[])&#123; if(params[DESTINATION_PARAM] != true)&#123; printDir(".", 0, params); &#125;else&#123; printDir(argv[optind], 0, params); &#125;&#125;void printDir(char *dir, int depth, bool params[])&#123; DIR *destination_directory = opendir(dir); if(destination_directory == NULL)&#123;//如果打开失败，给出提示，并退出。 printf("ls: 打开文件夹 %s 失败。\n", dir); // exit(-1); return; &#125; struct dirent *entry; struct stat statbuf; chdir(dir);//更换工作路径 while((entry = readdir(destination_directory)) != NULL)&#123; lstat(entry-&gt;d_name, &amp;statbuf); //-d 显示目录名称而非其内容 if(params[d_PARAM] == true)&#123; printf("%*s%s/ \n", depth, " ", dir); //-i 显示文件和目录的索引节点号 if(params[i_PARAM] == true)&#123; printf("%*s%ld\n", depth, " inode:", statbuf.st_ino); &#125; //-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 if(params[l_PARAM] == true)&#123; printf("%*s%d\t", depth, " 权限：", statbuf.st_mode);//权限 printf("%*s%d\t", depth, " 拥有者：", statbuf.st_uid);//拥有者 printf("%*s%d\t", depth, " 组ID：", statbuf.st_gid);//组名 printf("%*s%ld 字节\n", depth, " 文件大小：", statbuf.st_size);//文件大小 &#125; exit(0); &#125; if(S_ISDIR(statbuf.st_mode))&#123;//如果是目录 if(params[a_PARAM] == false &amp;&amp; (strcmp(entry-&gt;d_name, ".")==0 || strcmp(entry-&gt;d_name, "..")==0) )&#123; //不显示 . 和 .. 文件夹 continue; &#125; printf("%*s%s/ \n", depth, " ", entry-&gt;d_name); //-i 显示文件和目录的索引节点号 if(params[i_PARAM] == true)&#123; printf("%*s%ld\n", depth, " inode:", statbuf.st_ino); &#125; //-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 if(params[l_PARAM] == true)&#123; printf("%*s%d\t", depth, " 权限：", statbuf.st_mode);//权限 printf("%*s%d\t", depth, " 拥有者：", statbuf.st_uid);//拥有者 printf("%*s%d\t", depth, " 组ID：", statbuf.st_gid);//组名 printf("%*s%ld 字节\n", depth, " 文件大小：", statbuf.st_size);//文件大小 &#125; //-R 若目录下有文件，则以下之文件亦皆递归依序列出 //若没有，直接跳出第一次循环即可 if(params[R_PARAM] == true)&#123; printDir(entry-&gt;d_name, depth + 4, params); &#125; &#125;else&#123;//一般文件 //如果没有 -a 则忽略以.开头的文件 if(params[a_PARAM] == false &amp;&amp; (entry-&gt;d_name[0] == '.'))&#123; continue; &#125; printf("%*s%s \n", depth, " ", entry-&gt;d_name);//只列出名字 //-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 if(params[l_PARAM] == true)&#123; printf("%*s%d\t", depth, " 权限：", statbuf.st_mode);//权限 printf("%*s%d\t", depth, " 拥有者：", statbuf.st_uid);//拥有者 printf("%*s%d\t", depth, " 组ID：", statbuf.st_gid);//组名 printf("%*s%ld 字节\n", depth, " 文件大小：", statbuf.st_size);//文件大小 &#125; //-i 显示文件和目录的索引节点号 if(params[i_PARAM] == true)&#123; printf("%*s%ld\n", depth, " inode:", statbuf.st_ino); &#125; &#125; &#125; chdir(".."); closedir(destination_directory);&#125;int main(int argc, char* argv[])&#123; bool params[PARAM_TYPE_NUM] = &#123;false&#125;;//首先全部设为false handle_params(argc, argv, params, "alRdi::"); handle_ls_command(params, argv); exit(0);&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--3D图形斜投影]]></title>
    <url>%2F2018%2F10%2F28%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-3D%E5%9B%BE%E5%BD%A2%E6%96%9C%E6%8A%95%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[平行投影分为正投影和斜投影。当投影线与投影面不垂直，也就是说，投影线与投影面相倾斜时，所得到的物体的投影叫做斜投影。 利用矩阵变换同样可以得到3D图形几何变换，我将图形学–图形几何变换一文中的矩阵类进行修改，再加上重写了一个CPoint3D类，就可以简单实现3D图形的 斜等测轴测投影图 和 斜二测轴测投影图 。 使用时，直接调用函数 CPoint3D::cavalier_projection 和 CPoint3D::cabinet_projection 即可。 读者若有其他变换需求，只需模仿这两种变换，将变换矩阵的值进行修改即可。CPoint3D.h12345678910111213141516171819202122232425#pragma onceclass CPoint3D&#123;public: CPoint3D(); ~CPoint3D(); CPoint3D(int x, int y, int z);private: int x; int y; int z; public: void setX(int value); int getX(); void setY(int value); int getY(); void setZ(int value); int getZ(); static void CPoint3DToCPoint(CPoint3D points_3d[], CPoint points[], int point_number); static void cavalier_projection(CPoint3D points_3d[], CPoint points[], int point_number);//斜等测轴测投影图 static void cabinet_projection(CPoint3D points_3d[], CPoint points[], int point_number); //斜二测轴测投影图&#125;; CPoint3D.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include "stdafx.h"#include "CPoint3D.h"#include "MatrixTransformation3D.h"CPoint3D::CPoint3D()&#123; this-&gt;x = 0; this-&gt;y = 0; this-&gt;z = 0;&#125;CPoint3D::~CPoint3D()&#123;&#125;CPoint3D::CPoint3D(int x, int y, int z)&#123; this-&gt;x = x; this-&gt;y = y; this-&gt;z = z;&#125;void CPoint3D::setX(int value)&#123; this-&gt;x = value;&#125;int CPoint3D::getX()&#123; return x;&#125;void CPoint3D::setY(int value)&#123; this-&gt;y = value;&#125;int CPoint3D::getY()&#123; return y;&#125;void CPoint3D::setZ(int value)&#123; this-&gt;z = value;&#125;int CPoint3D::getZ()&#123; return z;&#125;void CPoint3D::CPoint3DToCPoint(CPoint3D points_3d[], CPoint points[], int point_number)&#123; for(int i = 0; i &lt; point_number; i++) &#123; points[i].x = points_3d[i].getX(); points[i].y = points_3d[i].getY(); &#125;&#125;//斜等测轴测投影图void CPoint3D::cavalier_projection(CPoint3D points_3d[], CPoint points[], int point_number)&#123; const double PI = 3.1415926535; MatrixTransformation3D matrix_transformation_3d(points_3d, point_number); matrix_transformation_3d.oblique_projection(PI / 4, PI / 4); //alpha = PI / 4, beta = PI / 4 matrix_transformation_3d.matrixTo3DPoint(points_3d, point_number); CPoint3DToCPoint(points_3d, points, point_number);&#125;//斜二测轴测投影图void CPoint3D::cabinet_projection(CPoint3D points_3d[], CPoint points[], int point_number)&#123; const double PI = 3.1415926535; MatrixTransformation3D matrix_transformation_3d(points_3d, point_number); matrix_transformation_3d.oblique_projection(63.4 * PI / 180, PI / 4); //alpha = 63.4 * PI / 180, beta = PI / 4 matrix_transformation_3d.matrixTo3DPoint(points_3d, point_number); CPoint3DToCPoint(points_3d, points, point_number);&#125; MatrixTransformation3D.h1234567891011121314151617181920212223242526272829303132333435#pragma once#include "CPoint3D.h"class MatrixTransformation3D&#123;public: MatrixTransformation3D(); ~MatrixTransformation3D();private: int row;//矩阵行数 int column;//矩阵列数 double* pointMatrix;//点矩阵 double transforMatrix[4][4];//变换矩阵public: MatrixTransformation3D(CPoint3D points[], int pointNumber);private: bool setMatrixElement(int row, int column, double value); bool setMatrixElement(int row, int column, double value, double matrix[]); double getMatrixElement(int row, int column); double getMatrixElement(int row, int column, double matrix[]); bool setTransforMatrixElement(int row, int column, double value); void matrixMultiplication(); int round(double value);public: CPoint3D* MatrixTransformation3D::matrixTo3DPoint(CPoint3D points[], int point_number);//矩阵转为点数组 void MatrixTransformation3D::oblique_projection(double alpha, double beta);//斜投影&#125;; MatrixTransformation3D.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &quot;stdafx.h&quot;#include &quot;MatrixTransformation3D.h&quot;MatrixTransformation3D::MatrixTransformation3D()&#123; row = 0; column = 0; pointMatrix = NULL;&#125;MatrixTransformation3D::MatrixTransformation3D(CPoint3D points[], int pointNumber)&#123; row = pointNumber; column = 4; pointMatrix = new double[row * column]; for (int i = 1; i &lt;= row; i++) &#123; setMatrixElement(i, 1, points[i - 1].getX()); setMatrixElement(i, 2, points[i - 1].getY()); setMatrixElement(i, 3, points[i - 1].getZ()); setMatrixElement(i, 4, 1); &#125;&#125;MatrixTransformation3D::~MatrixTransformation3D()&#123; delete[] pointMatrix;&#125;bool MatrixTransformation3D::setMatrixElement(int row, int column, double value)&#123; return setMatrixElement(row, column, value, pointMatrix);&#125;bool MatrixTransformation3D::setMatrixElement(int row, int column, double value, double matrix[])&#123; int realIndex = (row - 1) * this-&gt;column + column - 1; if (realIndex &lt; this-&gt;row * this-&gt;column &amp;&amp; realIndex &gt;= 0) &#123; matrix[realIndex] = value; return true; &#125; return false;&#125;double MatrixTransformation3D::getMatrixElement(int row, int column)&#123; return getMatrixElement(row, column, pointMatrix);&#125;double MatrixTransformation3D::getMatrixElement(int row, int column, double matrix[])&#123; int realIndex = (row - 1) * this-&gt;column + column - 1; if (realIndex &lt; this-&gt;row * this-&gt;column &amp;&amp; realIndex &gt;= 0) &#123; return matrix[realIndex]; &#125; return 0;&#125;bool MatrixTransformation3D::setTransforMatrixElement(int row, int column, double value)&#123; if (row &lt;= this-&gt;row &amp;&amp; row &gt; 0 &amp;&amp; column &lt;= this-&gt;column &amp;&amp; column &gt; 0) &#123; transforMatrix[row - 1][column - 1] = value; return true; &#125; return false;&#125;void MatrixTransformation3D::matrixMultiplication()&#123; double* result = new double[row * column]; double tempResult; for (int m = 0; m &lt; row; m++) &#123; for (int s = 0; s &lt; column; s++) &#123; tempResult = 0.0; //变量使用前初始化,否则结果具有不确定性 for (int n = 0; n &lt; column; n++) &#123; tempResult += getMatrixElement(m + 1, n + 1) * transforMatrix[n][s]; &#125; setMatrixElement(m + 1, s + 1, tempResult, result); &#125; &#125; double* tempPointer = this-&gt;pointMatrix; this-&gt;pointMatrix = result; delete[] tempPointer;&#125;int MatrixTransformation3D::round(double value)&#123; return (int)(value + 0.5);&#125;CPoint3D* MatrixTransformation3D::matrixTo3DPoint(CPoint3D points[], int point_number)&#123; for (int i = 1; i &lt;= point_number; i++) &#123; points[i - 1].setX(round(getMatrixElement(i, 1))); points[i - 1].setY(round(getMatrixElement(i, 2))); points[i - 1].setZ(round(getMatrixElement(i, 3))); &#125; return points;&#125;//斜投影void MatrixTransformation3D::oblique_projection(double alpha, double beta)&#123; setTransforMatrixElement(1, 1, 1); setTransforMatrixElement(1, 2, 0); setTransforMatrixElement(1, 3, 0); setTransforMatrixElement(1, 4, 0); setTransforMatrixElement(2, 1, 0); setTransforMatrixElement(2, 2, 1); setTransforMatrixElement(2, 3, 0); setTransforMatrixElement(2, 4, 0); setTransforMatrixElement(3, 1, -cos(beta) / tan(alpha)); setTransforMatrixElement(3, 2, -sin(beta) / tan(alpha)); setTransforMatrixElement(3, 3, 0); setTransforMatrixElement(3, 4, 0); setTransforMatrixElement(4, 1, 0); setTransforMatrixElement(4, 2, 0); setTransforMatrixElement(4, 3, 0); setTransforMatrixElement(4, 4, 1); matrixMultiplication();&#125;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>几何变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--图形几何变换]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%9B%BE%E5%BD%A2%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[二维图形基本几何变换是指相对于坐标原点和坐标轴进行的几何变换，包括平移（Translate）、比例（Scale）、旋转（Rotate）、反射（Reflect）和错切（shear）5种变换。物体变换物体变换是通过变换物体上每一个顶点实现的，因此以点的二维基本几何变换为例讲解二维图形基本几何变换矩阵。 下面给出C++实现二维图形基本几何变换的具体代码。算法中只包含平移和旋转两种变换。使用时，直接调用函数translation 和 whirling 即可。读者若有其他变换需求，只需模仿这两种变换，将变换矩阵的值进行修改即可。 MatrixTransformation.h123456789101112131415161718192021222324252627282930313233class MatrixTransformation&#123;public: MatrixTransformation(); ~MatrixTransformation(); private: int row;//矩阵行数 int column;//矩阵列数 double* pointMatrix;//点矩阵 double transforMatrix[3][3];//变换矩阵public: MatrixTransformation(CPoint points[], int pointNumber);private: bool setMatrixElement(int row, int column, double value); bool setMatrixElement(int row, int column, double value, double matrix[]); double getMatrixElement(int row, int column); double getMatrixElement(int row, int column, double matrix[]); bool setTransforMatrixElement(int row, int column, double value); void matrixMultiplication();public: CPoint* matrixToPoint(CPoint points[], int point_number);//矩阵转为点数组 void translation(int offset_x, int offset_y);//平移 void whirling(double angle);//旋转 void whirling(int offset_x, int offset_y, double angle);//绕点(offset_x, offset_y)旋转&#125;; MatrixTransformation.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136MatrixTransformation::MatrixTransformation()&#123; row = 0; column = 0; pointMatrix = NULL;&#125;MatrixTransformation::MatrixTransformation(CPoint points[], int pointNumber)&#123; row = pointNumber; column = 3; pointMatrix = new double[row * column]; for(int i = 1; i &lt;= row; i++) &#123; setMatrixElement(i, 1, points[i - 1].x); setMatrixElement(i, 2, points[i - 1].y); setMatrixElement(i, 3, 1); &#125;&#125;MatrixTransformation::~MatrixTransformation()&#123; delete[] pointMatrix;&#125;bool MatrixTransformation::setMatrixElement(int row, int column, double value)&#123; return setMatrixElement(row, column, value, pointMatrix);&#125;bool MatrixTransformation::setMatrixElement(int row, int column, double value, double matrix[])&#123; int realIndex = (row - 1) * this-&gt;column + column - 1; if (realIndex &lt; this-&gt;row * this-&gt;column &amp;&amp; realIndex &gt;= 0) &#123; matrix[realIndex] = value; return true; &#125; return false;&#125;double MatrixTransformation::getMatrixElement(int row, int column)&#123; return getMatrixElement(row, column, pointMatrix);&#125;double MatrixTransformation::getMatrixElement(int row, int column, double matrix[])&#123; int realIndex = (row - 1) * this-&gt;column + column - 1; if (realIndex &lt; this-&gt;row * this-&gt;column &amp;&amp; realIndex &gt;= 0) &#123; return matrix[realIndex]; &#125; return 0;&#125;bool MatrixTransformation::setTransforMatrixElement(int row, int column, double value)&#123; if (row &lt;= 3 &amp;&amp; row &gt; 0 &amp;&amp; column &lt;= 3 &amp;&amp; column &gt; 0) &#123; transforMatrix[row - 1][column - 1] = value; return true; &#125; return false;&#125;void MatrixTransformation::matrixMultiplication()&#123; double* result = new double[row * column]; int tempResult; for (int m = 0; m &lt; row; m++) &#123; for (int s = 0; s &lt; column; s++) &#123; tempResult = 0; //变量使用前初始化,否则结果具有不确定性 for (int n = 0; n &lt; column; n++) &#123; tempResult += getMatrixElement(m + 1, n + 1) * transforMatrix[n][s]; &#125; setMatrixElement(m + 1, s + 1, tempResult, result); &#125; &#125; double* tempPointer = this-&gt;pointMatrix; this-&gt;pointMatrix = result; delete[] tempPointer;&#125;CPoint* MatrixTransformation::matrixToPoint(CPoint points[], int point_number)&#123; for(int i = 1; i &lt;= point_number; i++) &#123; points[i - 1].x = getMatrixElement(i, 1); points[i - 1].y = getMatrixElement(i, 2); &#125; return points;&#125;void MatrixTransformation::translation(int offset_x, int offset_y)&#123; setTransforMatrixElement(1, 1, 1); setTransforMatrixElement(1, 2, 0); setTransforMatrixElement(1, 3, 0); setTransforMatrixElement(2, 1, 0); setTransforMatrixElement(2, 2, 1); setTransforMatrixElement(2, 3, 0); setTransforMatrixElement(3, 1, offset_x); setTransforMatrixElement(3, 2, offset_y); setTransforMatrixElement(3, 3, 1); matrixMultiplication();&#125;void MatrixTransformation::whirling(double angle)&#123; setTransforMatrixElement(1, 1, cos(angle)); setTransforMatrixElement(1, 2, sin(angle)); setTransforMatrixElement(1, 3, 0); setTransforMatrixElement(2, 1, -sin(angle)); setTransforMatrixElement(2, 2, cos(angle)); setTransforMatrixElement(2, 3, 0); setTransforMatrixElement(3, 1, 0); setTransforMatrixElement(3, 2, 0); setTransforMatrixElement(3, 3, 1); matrixMultiplication();&#125;void MatrixTransformation::whirling(int offset_x, int offset_y, double angle)&#123; translation(-offset_x, -offset_y); whirling(angle); translation(offset_x, offset_y);&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>几何变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--扫描线种子填充算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%A7%8D%E5%AD%90%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法描述：种子填充算法原理和程序都很简单, 但由于多次递归, 费时、费内存, 效率不高。为了减少递归次数, 提高效率可以采用扫描线种子填充算法。 算法的基本过程如下: 当给定种子点 (x, y) 时, 首先填充种子点所在扫描线上的位于给定区域的一个区段, 然后确定与这一区段相连通的上、下两条扫描线上位于给定区域内的区段, 并依次保存下来。反复这个过程, 直到填充结束。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * begin_point 是起始点 * boundaryColor 是边界色 * fillColor 是填充色 * */void scanLineSeedFillingAlgorithm(CPoint begin_point, COLORREF boundaryColor, COLORREF fillColor, CDC* pDC)&#123; std::stack&lt;CPoint&gt; stack;//使用STL自带的栈容器 stack.push(begin_point);//将起点先入栈 CPoint* currentPoint = NULL;//当前操作的点 int x_left = 0, x_right = 0; while (!stack.empty())//栈不空时进行循环 &#123; currentPoint = &amp;stack.top();//访问栈顶元素 stack.pop();//删除栈顶元素 pDC-&gt;SetPixelV(*currentPoint, fillColor);//填充颜色 x_left = fillThisLine(currentPoint-&gt;x - 1, currentPoint-&gt;y, boundaryColor, fillColor, false, pDC) + 1; x_right = fillThisLine(currentPoint-&gt;x + 1, currentPoint-&gt;y, boundaryColor, fillColor, true, pDC) - 1; int tempY = currentPoint-&gt;y; searchNewLineSeed(&amp;stack, x_left, x_right, tempY + 1, boundaryColor, fillColor, pDC); searchNewLineSeed(&amp;stack, x_left, x_right, tempY - 1, boundaryColor, fillColor, pDC); &#125;&#125;/** * x 是该点横坐标 * y 是该点纵坐标 * boundaryColor 是边界色 * fillColor 是填充色 * sign是填充标志，当sign是false时，向左扫描；当sign是true时，向右扫描。 * */int fillThisLine(int x, int y, COLORREF boundaryColor, COLORREF fillColor, BOOL sign, CDC* pDC)&#123; COLORREF currentColor = pDC-&gt;GetPixel(x, y); if (sign == false)//当sign是false时，向左扫描。 &#123; while (currentColor != boundaryColor)//当当前颜色不是边界线颜色时进行循环，否则跳出循环。 &#123; pDC-&gt;SetPixelV(x, y, fillColor);//向左填充颜色 currentColor = pDC-&gt;GetPixel(--x, y);//获取左侧颜色 &#125; &#125; else//当sign是true时，向右扫描。 &#123; while (currentColor != boundaryColor)//当当前颜色不是边界线颜色时进行循环，否则跳出循环。 &#123; pDC-&gt;SetPixelV(x, y, fillColor);//向右填充颜色 currentColor = pDC-&gt;GetPixel(++x, y);//获取右侧颜色 &#125; &#125; return x;&#125;/** * stack是栈指针 * x_left 是左边界 * x_right 是右边界 * y 是当前扫描线 * boundaryColor 是边界色 * fillColor 是填充色 */ void searchNewLineSeed(std::stack&lt;CPoint&gt; *stack, int x_left, int x_right, int y, COLORREF boundaryColor, COLORREF fillColor, CDC* pDC)&#123; BOOL findNewSeed = false; for(; x_left &lt;= x_right; x_left++) &#123; if(pDC-&gt;GetPixel(x_left, y) != boundaryColor &amp;&amp; pDC-&gt;GetPixel(x_left, y) != fillColor) &#123; findNewSeed = true; break; &#125; &#125; if(findNewSeed) &#123; stack-&gt;push(CPoint(x_left, y)); &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>填充算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--区域填充算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法描述：区域填充是指从区域内的某一个象素点（种子点）开始，由内向外将填充色扩展到整个区域内的过程。区域是指已经表示成点阵形式的填充图形，它是相互连通的一组像素的集合。 区域填充算法（边界填充算法和泛填充算法）是根据区域内的一个已知象素点（种子点）出发，找到区域内其他象素点的过程，所以把这一类算法也成为种子填充算法。 下面给出八连通区域填充算法（四连通区域填充算法类似）123456789101112131415161718192021222324252627282930313233343536373839404142/** * begin_point 是起始点 * boundaryColor 是边界色 * fillColor 是填充色 * */ void eightAdjacentPointFillingAlgorithm(CPoint begin_point, COLORREF boundaryColor, COLORREF fillColor, CDC* pDC)&#123; std::stack&lt;CPoint&gt; stack;//使用STL自带的栈容器 stack.push(begin_point);//将起点先入栈 CPoint* currentPoint = NULL;//当前操作的点 while(!stack.empty())//栈不空时进行循环 &#123; currentPoint = &amp;stack.top();//访问栈顶元素 stack.pop();//删除栈顶元素 pDC-&gt;SetPixelV(*currentPoint, fillColor);//填充颜色 isFilling(&amp;stack, currentPoint-&gt;x - 1, currentPoint-&gt;y, boundaryColor, fillColor, pDC);//左侧点 isFilling(&amp;stack, currentPoint-&gt;x - 1, currentPoint-&gt;y - 1, boundaryColor, fillColor, pDC);//左上点 isFilling(&amp;stack, currentPoint-&gt;x, currentPoint-&gt;y - 1, boundaryColor, fillColor, pDC);//上侧点 isFilling(&amp;stack, currentPoint-&gt;x + 1, currentPoint-&gt;y + 1, boundaryColor, fillColor, pDC);//右上点 isFilling(&amp;stack, currentPoint-&gt;x + 1, currentPoint-&gt;y, boundaryColor, fillColor, pDC);//右侧点 isFilling(&amp;stack, currentPoint-&gt;x + 1, currentPoint-&gt;y - 1, boundaryColor, fillColor, pDC);//右下点 isFilling(&amp;stack, currentPoint-&gt;x, currentPoint-&gt;y - 1, boundaryColor, fillColor, pDC);//下侧点 isFilling(&amp;stack, currentPoint-&gt;x - 1, currentPoint-&gt;y - 1, boundaryColor, fillColor, pDC);//左下点 &#125;&#125;/** * stack 是栈指针 * boundaryColor 是边界色 * fillColor 是填充色 */ void isFilling(std::stack&lt;CPoint&gt; *stack, int x, int y, COLORREF boundaryColor, COLORREF fillColor, CDC* pDC)&#123; COLORREF currentColor = pDC-&gt;GetPixel(x, y);;//获得当前操作点颜色 if (currentColor != boundaryColor &amp;&amp; currentColor != fillColor) &#123; stack-&gt;push(CPoint(x, y)); &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>填充算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--边缘填充算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E8%BE%B9%E7%BC%98%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法描述：边缘填充算法是先求出多边形的每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取为补色（或反色）。按任意顺序处理完多边形的所有边后，就完成了多边形的填充任务。 边缘填充算法利用了图像处理中的求“补”或求“反”的概念，对于黑白图像，求补就是把RGB(255,255,255)（白色）的像素置为RGB(0,0,0)（黑色），反之亦然；对于彩色图像，求补就是将背景色置为填充色，反之亦然。求补的一条基本性质是一个像素求补两次就恢复为原色。如果多边形内部的像素被求补偶数次，保持原色，如果被求补奇数次，显示填充色。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * points 是点数组 * point_num 是点的个数 * foregroundColor 是前景色 * backgroundColor 是背景色 * fence 是栅栏 * */void edgeFillingAlgorithm(CPoint points[], int point_num, COLORREF foregroundColor, COLORREF backgroundColor, int fence, CDC *pDC)&#123; int yMin, yMax;//边的最小y和最大y //x,y为当前点x、y坐标，reciprocalOfSlope为斜率分之一，1/k double x, reciprocalOfSlope; int y; for (int i = 0; i &lt; point_num; i++) &#123; int j = (i + 1) % point_num;//j为相对于i的下一个点 if (points[i].y - points[j].y != 0) &#123; reciprocalOfSlope = (points[i].x - points[j].x) * 1.0 / (points[i].y - points[j].y); //TODO：以下处理，得到每条边的y的最大值和最小值 if (points[i].y &lt; points[j].y)//斜率不为0时 &#123; yMin = points[i].y; yMax = points[j].y; x = points[i].x; &#125; else &#123; yMin = points[j].y; yMax = points[i].y; x = points[j].x; &#125; for (y = yMin; y &lt; yMax; y++)//沿每条扫描线处理 &#123; //对每条扫描线与边的交点的右侧像素循环，其中max_X是包围圈的右边界 if(x &lt; fence) &#123; for (int tempX = Round(x); tempX &lt; fence; tempX++) &#123; if (pDC-&gt;GetPixel(tempX, y) == foregroundColor) &#123; pDC-&gt;SetPixelV(tempX, y, backgroundColor); &#125; else &#123; pDC-&gt;SetPixelV(tempX, y, foregroundColor); &#125; &#125; &#125; else &#123; for (int tempX = fence; tempX &lt; x; tempX++) &#123; if (pDC-&gt;GetPixel(tempX, y) == foregroundColor) &#123; pDC-&gt;SetPixelV(tempX, y, backgroundColor); &#125; else &#123; pDC-&gt;SetPixelV(tempX, y, foregroundColor); &#125; &#125; &#125; x = x + reciprocalOfSlope; &#125; &#125; else //斜率为0时 &#123; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>图形学</tag>
        <tag>填充算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形学--有效边表填充算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E6%9C%89%E6%95%88%E8%BE%B9%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法描述：有效边表填充算法通过维护边表和有效边表，避开了扫描线与多边形所有边求交的复杂运算。 填充原理是按照扫描线从小到大的移动顺序，计算当前扫描线与有效边的交点，然后把这些交点按x值递增的顺序进行排序、配对，以确定填充区间，最后用指定颜色填充区间内的所有像素，即完成填充工作。有效边表填充算法已成为目前最为有效的多边形填充算法之一。 Edge.h12345678910111213141516#pragma onceclass Edge&#123;public: Edge(); ~Edge(); Edge(double x, int yMax, double reciprocalOfSlope, Edge* pNext); void setEdge(double x, int yMax, double reciprocalOfSlope, Edge* pNext); void reUseEdge();public: double x; int yMax; double reciprocalOfSlope;//斜率分之一，1/k Edge* pNext;&#125;; Edge.cpp1234567891011121314151617181920212223242526272829303132333435363738#include "stdafx.h"#include "Edge.h"Edge::Edge()&#123; x = 0.0; yMax = 0; reciprocalOfSlope = 0.0; pNext = NULL;&#125;Edge::~Edge()&#123;&#125;Edge::Edge(double x, int yMax, double reciprocalOfSlope, Edge* pNext)&#123; this-&gt;x = x; this-&gt;yMax = yMax; this-&gt;reciprocalOfSlope = reciprocalOfSlope; this-&gt;pNext = pNext;&#125;void Edge::setEdge(double x, int yMax, double reciprocalOfSlope, Edge* pNext)&#123; this-&gt;x = x; this-&gt;yMax = yMax; this-&gt;reciprocalOfSlope = reciprocalOfSlope; this-&gt;pNext = pNext;&#125;void Edge::reUseEdge()&#123; this-&gt;x = this-&gt;x + this-&gt;reciprocalOfSlope; this-&gt;pNext = NULL;&#125; Bucket.h12345678910111213141516171819#pragma once#include "Edge.h"class Bucket&#123;public: Bucket(); ~Bucket(); Bucket(int scanLine, Edge* pEdge, Bucket* pNext); static Bucket* creatBucket(CPoint points[], int points_num); static Bucket* creatEdgeTable(CPoint points[], Edge edges[], int points_num, Bucket* headBucket); static void addEdge(Bucket* currentBucket, Edge* edge);public: int scanLine; Edge* pEdge; Bucket* pNext;&#125;; Bucket.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include "stdafx.h"#include "Bucket.h"Bucket::Bucket()&#123; scanLine = 0; pEdge = NULL; pNext = NULL;&#125;Bucket::~Bucket()&#123;&#125;Bucket::Bucket(int scanLine, Edge* pEdge, Bucket* pNext)&#123; this-&gt;scanLine = scanLine; this-&gt;pEdge = pEdge; this-&gt;pNext = pNext;&#125;Bucket* Bucket::creatBucket(CPoint points[], int points_num)&#123; if (points_num == 0) &#123; return NULL; &#125; int scanMin = points[0].y, scanMax = points[0].y;//确定扫描线的最小值和最大值。初始值使用第一个点的y值。 for (int i = 1; i &lt; points_num; i++) &#123; if (points[i].y &lt; scanMin) &#123; scanMin = points[i].y;//扫描线的最小值 &#125; if (points[i].y &gt; scanMax) &#123; scanMax = points[i].y;//扫描线的最大值 &#125; &#125; //TODO: 以下是创建桶的代码，此时桶上不加入边 Bucket *headBucket = new Bucket(scanMin, NULL, NULL);//建立桶的头结点 Bucket *currentBucket = headBucket; for (int i = scanMin + 1; i &lt;= scanMax; i++)//建立桶的其它结点 &#123; currentBucket-&gt;pNext = new Bucket(i, NULL, NULL);//新建一个桶结点 currentBucket = currentBucket-&gt;pNext;//使currentBucket指向新建的桶结点 &#125; return headBucket;&#125;Bucket* Bucket::creatEdgeTable(CPoint points[], Edge edges[], int points_num, Bucket* headBucket)&#123; Bucket *currentBucket = NULL; Edge *currentEdge = NULL; for (int i = 0; i &lt; points_num; i++)//访问每个顶点 &#123; int j = (i + 1) % points_num;//边的第二个顶点，points[i]和points[j]构成一条边 currentBucket = headBucket;//从桶链表的头结点开始循环 if (points[j].y &gt; points[i].y)//若终点比起点高 &#123; while (currentBucket-&gt;scanLine != points[i].y)//在桶内寻找该边的yMin &#123; currentBucket = currentBucket-&gt;pNext;//移到下一个桶结点 &#125;//跳出循环时，找到对应的桶，即为currentBucket edges[i].setEdge(points[i].x, points[j].y, (points[j].x - points[i].x) * 1.0 / (points[j].y - points[i].y), NULL);//将该边记入数组edges中 addEdge(currentBucket, &amp;edges[i]);//将该边加入桶中 &#125; if (points[j].y &lt; points[i].y)//终点比起点低 &#123; while (currentBucket-&gt;scanLine != points[j].y)//在桶内寻找该边的yMin &#123; currentBucket = currentBucket-&gt;pNext;//移到下一个桶结点 &#125;//跳出循环时，找到对应的桶，即为currentBucket edges[i].setEdge(points[j].x, points[i].y, (points[i].x - points[j].x) * 1.0 / (points[i].y - points[j].y), NULL);//将该边记入数组edges中 addEdge(currentBucket, &amp;edges[i]);//将该边加入桶中 &#125; &#125; return headBucket;&#125;//按照x的大小顺序将边加入桶中void Bucket::addEdge(Bucket* currentBucket, Edge* edge)&#123; if (currentBucket-&gt;pEdge == NULL)//若当前桶结点上没有链接边结点 &#123; currentBucket-&gt;pEdge = edge;//第一个边结点直接连接到对应的桶中 &#125; else if(edge-&gt;x &lt; currentBucket-&gt;pEdge-&gt;x)//比首结点小时 &#123; Edge *tempEdge = currentBucket-&gt;pEdge; currentBucket-&gt;pEdge = edge; edge-&gt;pNext = tempEdge; &#125; else //如果当前边已连有边结点 &#123; Edge *currentEdge = currentBucket-&gt;pEdge; while (currentEdge-&gt;pNext) &#123; if(currentEdge-&gt;pNext-&gt;x &gt;= edge-&gt;x &amp;&amp; currentEdge-&gt;x &lt; edge-&gt;x)//currentEdge的x比该边x小 且currentEdge下一个边比比该边x大时插入 &#123; Edge* tempEdge = currentEdge-&gt;pNext; currentEdge-&gt;pNext = edge; edge-&gt;pNext = tempEdge; return; &#125; currentEdge = currentEdge-&gt;pNext; &#125; //跳出循环时，说明edge-&gt;x比最后一个结点都大，所以放在最后 currentEdge-&gt;pNext = edge; edge-&gt;pNext = NULL; &#125;&#125; main.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * headBucket 是桶表头节点 * colorref 是填充颜色 */ void effectiveEdgeTableFillingAlgorithm(Bucket* headBucket ,COLORREF colorref, CDC *pDC)&#123; Edge *currentEdge = NULL, *tempEdge = NULL; Bucket* currentBucket = headBucket;//当前操作的桶，从第一个开始 Bucket* tempBucket = NULL; //访问所有桶结点 while(currentBucket-&gt;pNext) //for(currentBucket = headBucket; currentBucket != NULL; currentBucket = currentBucket-&gt;pNext) &#123; currentEdge = currentBucket-&gt;pEdge;//首先currentEdge指向当前扫描线的第一个边 //TODO: 以下是当前桶的绘图的代码。 bool in = true; //设置一个bool变量in，初始值为真，用于判断当前选择像素点是否在图形内部 tempEdge = currentEdge; while(tempEdge-&gt;pNext) &#123; if (in)//若在内部则绘图 &#123; for (double x = tempEdge-&gt;x; x &lt; tempEdge-&gt;pNext-&gt;x; x++) &#123; pDC-&gt;SetPixelV(x, currentBucket-&gt;scanLine, colorref); //Sleep(1); &#125; &#125; in = !in;//in取反 tempEdge = tempEdge-&gt;pNext; &#125; //TODO：以下是处理下个桶的代码。即将当前桶的边处理，得出下个桶的有效边，并插入下个桶中，同时释放当前桶的资源。 //遍历该桶 while(currentEdge) &#123; if(currentEdge-&gt;yMax &gt; currentBucket-&gt;scanLine + 1) //若满足加入条件,则将该结点进行修改并按顺序插入下一个桶 &#123; tempEdge = currentEdge; currentEdge = currentEdge-&gt;pNext; tempEdge-&gt;reUseEdge();//修改信息 Bucket::addEdge(currentBucket-&gt;pNext, tempEdge);//插入下个桶 &#125; else//否则释放该边的资源 &#123; tempEdge = currentEdge; currentEdge = currentEdge-&gt;pNext; //if(tempEdge != NULL)&#123; delete tempEdge; &#125; &#125; &#125; tempBucket = currentBucket; currentBucket = currentBucket-&gt;pNext; delete tempBucket; &#125;&#125;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>填充算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大类分流软件设计]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%A4%A7%E7%B1%BB%E5%88%86%E6%B5%81%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[大类分流基本思想是将6个文件模拟为一个按绩点顺序存放的队列，按排行和志愿顺序对队首元素分配专业。 将队首元素按志愿顺序映射为一个数组。对队首每个元素，如果当前志愿的专业人数达到人数限制，则判断下一个志愿。如果所有志愿人数都已满，则放入另一个未处理学生的队列中，等一轮分配完再处理。下面是具体算法。 已知n个学生，每个学生最多5个志愿。已知6个专业的人数限制。 将6个专业对应的文件读入6个存放学生信息的队列中； 设计数器 count.每个队首的绩点排名等于count弹出，弹出的元素根据志愿顺序映射到长度为6的数组对应的位置，count加上弹出的学生的人数；绩点排行小于count说明已分配过。则直接弹出 根据数组顺序来分配专业。如果当前志愿人数未满，写入结果数组，对应专业当前人数+1；人数已满则判断下一个志愿；所有志愿人数都满则排入未处理学生的队列。 最后处理未处理学生的队列，将他们分配到当前专业人数未满的专业即可。 需要注意注意的是第二部分，有可能有绩点排行相同的情况，所做的处理是把弹出的数组处理为一个链表数组。排名相同的学生按专业顺序插入到对应数组对应位置的链表中去。处理时仍然按次序处理即可。 这个算法的关键是注意到6个文件本身是排好序的，所以并没有将所有文件合并为一个有序序列，而是通过处理来模拟达到队列的效果。 处理的关键是每次“只处理6个文件的一行中绩点最高的学生的分配”，提高效率的关键是将绩点最高的学生的信息按志愿顺序映射存储再分配，因为是按志愿顺序处理。这样排名靠前的学生处理效率将大大提高，排名靠后的学生如果是根据自身情况选择合适的志愿，处理效率也会提高。 这儿是测试得到的结果 项目已经托管到 GitHub，戳我 。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown文本转为Html]]></title>
    <url>%2F2018%2F06%2F17%2FMarkdown%E6%96%87%E6%9C%AC%E8%BD%AC%E4%B8%BAHtml%2F</url>
    <content type="text"><![CDATA[利用Java语言，使用正则表达式借助编译原理的知识，制作出一个简易的将Markdown文本转为Html的程序。 网页中不方便代码展示及维护，故托管到Github，请移步 这里。 已经支持中文！~由于没有进行编码和解码处理，目前暂时只支持英文的转化。~ 支持的操作： 标题 分割线 有序列表和无序列表 斜体 加粗 删除线 标记 图片链接 网址链接和邮箱链接 不支持的操作： 引用片段 代码片段 表格 其他罕见功能 （持续更新）]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++实现简单计算器]]></title>
    <url>%2F2018%2F05%2F12%2FC-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[利用编译原理中递归下降的 语法分析 和 语义分析 ，使用 C++ 实现简单计算器。 文法如下： EXP -&gt; TERM {AlphaOP TERM} TERM -&gt; FACTOR {BetaOP FACTOR} FACTOR -&gt; (EXP) | number AlphaOP -&gt; + | - BetaOP -&gt; * | \ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;/* * EXP -&gt; TERM &#123;AlphaOP TERM&#125; * TERM -&gt; FACTOR &#123;BetaOP FACTOR&#125; * FACTOR -&gt; (EXP) | number * AlphaOP -&gt; + | - * BetaOP -&gt; * | \ */string inputExp;string::iterator ite;void handleError();void matchChar(char token);double matchDigit();double factor();double term();double expression();//错误处理void handleError() &#123; cerr &lt;&lt; "Error expression ! " + inputExp &lt;&lt;endl; exit(-1);&#125;//匹配字符void matchChar(char token) &#123; if (*ite == token) &#123; ite++; &#125; else &#123; handleError(); &#125;&#125;//匹配数字double matchDigit() &#123; string tempString = ""; while (isdigit(*ite)) &#123; tempString += *ite; ite++; &#125; istringstream iss(tempString); double temp; iss &gt;&gt; temp; return temp;&#125;double factor() &#123; double temp; if (isdigit(*ite)) &#123; temp = matchDigit(); &#125; else if (*ite == '(') &#123; matchChar('('); //处理负数 if(*ite == '-')&#123; ite++; temp = matchDigit() * (-1); &#125; else&#123; temp = expression(); &#125; matchChar(')'); &#125; else &#123; handleError(); &#125; return temp;&#125;double term() &#123; double temp = factor(); while (*ite == '*' || *ite == '/') &#123; if (*ite == '*') &#123; matchChar('*'); temp = temp * factor(); &#125; else &#123; matchChar('/'); temp = temp / factor(); &#125; &#125; return temp;&#125;double expression() &#123; double temp = term(); while (*ite == '+' || *ite == '-') &#123; if (*ite == '+') &#123; matchChar('+'); temp = temp + factor(); &#125; else &#123; matchChar('-'); temp = temp - factor(); &#125; &#125; return temp;&#125;int main() &#123; double result = 0; cout &lt;&lt; "请输入表达式："; cin &gt;&gt; inputExp; //加上空格防止迭代器溢出 inputExp += " "; ite = inputExp.begin(); while (*ite != inputExp.back()) &#123; result = expression(); &#125; cout &lt;&lt; result &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OperateFile-LAN-Java]]></title>
    <url>%2F2018%2F04%2F21%2FOperateFile-LAN-Java%2F</url>
    <content type="text"><![CDATA[利用Java RMI实现LAN（局域网）内服务端和客户端的文件传输及文件简单操作。 网页中不方便代码展示及维护，故托管到Github，请移步 [这里](https://github.com/CongLinDev/OperateFile-LAN-Java) 。 （持续更新） 预计于2018年6月份交付。 已交付。]]></content>
      <categories>
        <category>分布式技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solutions to problems on LeetCode]]></title>
    <url>%2F2018%2F04%2F05%2FSolutions-to-problems-on-LeetCode%2F</url>
    <content type="text"><![CDATA[分享一些我在LeetCode(https://leetcode.com)的算法收获。使用C++ / Java 语言解决问题 （持续更新） 两数之和 给定一个整数数列，找出其中和为特定值的那两个数。你可以假设每个输入都只会有一种答案，同样的元素不能被重用。 示例：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 123456789101112131415161718192021//C++class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int sum; vector&lt;int&gt; sumVec; for(int i = 0; i &lt; nums.size(); i++)&#123; for(int j = i + 1; j&lt;nums.size(); j++)&#123; sum = nums[i]+nums[j]; if(sum == target)&#123; sumVec.push_back(i); sumVec.push_back(j); return sumVec; &#125; &#125; &#125; return sumVec; &#125;&#125;; 两数相加 给定两个非空链表来代表两个非负整数，位数按照逆序方式存储，它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 12345678910111213141516171819202122232425262728293031323334353637//Java/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy=new ListNode(-1); ListNode cur=dummy; int carry = 0; while((l1 != null)||(l2 != null)) &#123; //要注意两个链表的长度不同的情况，当链表为null时，设置为零 int d1=(l1==null? 0:l1.val); int d2=(l2==null? 0:l2.val); int sum=d1 + d2 + carry; //carry=sum/10; carry=sum&gt;=10? 1:0; cur.next=new ListNode(sum%10); cur=cur.next; //null无法链接next if(l1 != null) &#123; l1=l1.next; &#125; if(l2 != null) &#123; l2=l2.next; &#125; &#125; if(carry &gt; 0) &#123; cur.next=new ListNode(carry); &#125; return dummy.next; &#125;&#125; 无重复字符的最长子串 给定一个字符串，找出不含有重复字符的最长子串的长度。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例：给定&quot;abcabcbb&quot;，没有重复字符的最长子串是&quot;abc&quot;，那么长度就是3。给定&quot;bbbbb&quot;，最长的子串就是&quot;b&quot;，长度是1。给定&quot;pwwkew&quot;，最长子串是&quot;wke&quot;，长度是3。请注意答案必须是一个子串，&quot;pwke&quot;是子序列而不是子串。 123456789101112131415161718192021//Javapublic class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int res = 0; //记录结果 int len = 0; //记录长度 int start = 0; //记录开始索引 for(int i = 0; i &lt; s.length(); i++)&#123; if(map.containsKey(s.charAt(i)) &amp;&amp; map.get(s.charAt(i)) &gt;= start)&#123; start = map.get(s.charAt(i)) + 1; &#125; len = i - start + 1; //记录长度 map.put(s.charAt(i),i); res = Math.max(res,len); //记录最大值 &#125; return res; &#125;&#125; 两个排序数组的中位数 有两个大小为 m 和 n 的排序数组nums1和nums2。请找出两个排序数组的中位数并且总的运行时间复杂度为 O(log (m+n))。 示例1：nums1 = [1, 3]nums2 = [2]中位数是 2.0 示例2:nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Java/*题目要求O(log(m+n))的时间复杂度，一般来说都是分治法或者二分搜索。首先我们先分析下题目，假设两个有序序列共有n个元素（根据中位数的定义我们要分两种情况考虑），当n为奇数时，搜寻第(n/2+1)个元素，当n为偶数时，搜寻第(n/2+1)和第(n/2)个元素，然后取他们的均值。进一步的，我们可以把这题抽象为“搜索两个有序序列的第k个元素”。如果我们解决了这个k元素问题，那中位数不过是k的取值不同罢了。假设序列都是从小到大排列，对于第一个序列中前p个元素和第二个序列中前q个元素，我们想要的最终结果是：p+q等于k-1,且一序列第p个元素和二序列第q个元素都小于总序列第k个元素。因为总序列中，必然有k-1个元素小于等于第k个元素。这样第p+1个元素或者第q+1个元素就是我们要找的第k个元素。所以，我们可以通过二分法将问题规模缩小，假设p=k/2-1，则q=k-p-1，且p+q=k-1。如果第一个序列第p个元素小于第二个序列第q个元素，我们不确定二序列第q个元素是大了还是小了，但一序列的前p个元素肯定都小于目标，所以我们将第一个序列前p个元素全部抛弃，形成一个较短的新序列。然后，用新序列替代原先的第一个序列，再找其中的第k-p个元素（因为我们已经排除了p个元素，k需要更新为k-p），依次递归。同理，如果第一个序列第p个元素大于第二个序列第q个元素，我们则抛弃第二个序列的前q个元素。递归的终止条件有如下几种：较短序列所有元素都被抛弃，则返回较长序列的第k个元素（在数组中下标是k-1），一序列第p个元素等于二序列第q个元素，此时总序列第p+q=k-1个元素的后一个元素，也就是总序列的第k个元素注意每次递归不仅要更新数组起始位置（起始位置之前的元素被抛弃），也要更新k的大小（扣除被抛弃的元素）*/class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len1 = nums1.length; int len2 = nums2.length; int k = (len1 + len2) / 2; if((len1 + len2) % 2 != 0)&#123; return findKth(nums1, nums2, 0, 0, len1, len2, k + 1); &#125; else &#123; return (findKth(nums1,nums2,0,0,len1,len2,k)+findKth(nums1,nums2,0,0,len1,len2,k+1))/2; &#125; &#125; //通过二分法将问题规模缩小,找出arr1和arr2中第k个元素，默认arr1长度小于等于arr2 public double findKth(int[] arr1, int[]arr2, int start1, int start2, int len1, int len2, int k)&#123; if(len1 &gt; len2)&#123; return findKth(arr2, arr1, start2, start1, len2, len1, k); &#125; if(len1 == 0)&#123; return arr2[start2 + k - 1]; &#125; if(k == 1)&#123; return Math.min(arr1[start1], arr2[start2]); &#125; //假设p=k/2-1，则q=k-p-1 int p = Math.min(k/2, len1); int q = k - p; if(arr1[start1 + p - 1] &lt; arr2[start2 + q - 1])&#123; return findKth(arr1, arr2, start1 + p, start2, len1 - p, len2, k - p); &#125;else if(arr1[start1 + p - 1] &gt; arr2[start2 + q - 1])&#123; return findKth(arr1, arr2, start1, start2 + q, len1, len2 - q, k - q); &#125; else &#123; return arr1[start1 + p - 1]; &#125; &#125;&#125; 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例1：输入: “babad”输出: “bab”注意: “aba”也是一个有效答案。 示例2:输入: “cbbd”输出: “bb” 12345678910111213141516171819202122232425262728//java//利用Manacher Algorithm 算法复杂度为O(n)public class Solution &#123; private int lo, maxLen; public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) return s; for (int i = 0; i &lt; len-1; i++) &#123; extendPalindrome(s, i, i); //assume odd length, try to extend Palindrome as possible extendPalindrome(s, i, i+1); //assume even length. &#125; return s.substring(lo, lo + maxLen); &#125; private void extendPalindrome(String s, int j, int k) &#123; while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123; j--; k++; &#125; if (maxLen &lt; k - j - 1) &#123; lo = j + 1; maxLen = k - j - 1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表实现简单列车查询系统]]></title>
    <url>%2F2018%2F03%2F31%2F%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%88%97%E8%BD%A6%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[利用C++链表知识实现简单的列车查询系统。 设计目的综合运用链表知识解决实际问题的能力。 设计内容设计火车售票处的计算机系统，可以为客户提供下列各项服务： 查询列车信息：根据旅客提出的起始站和终点站名，或者列车车次，输出下列信息：列车车次、发车时刻、到达时刻、运行时间，以及每个途经站点的站名、到达时间、发车时间、运行里程等信息； 录入列车信息； 修改列车信息； 删除列车信息； 浏览所有列车信息； 其它必要功能。 设计要求 要求采用链表方式存储所有列车车次基本信息（如车次名称等），对于其中的每个列车车次，也采用链表方式存储各个途经站点信息； 能够支持查询、修改、增加、删除等信息； 如有时间，建议提供保存和打开功能，用户可以把所有信息保存到硬盘文件上，也可以从硬盘文件上读取信息； 界面友好。 代码实现station.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#pragma once#include &lt;string&gt;#include &lt;sstream&gt;using std::ostream;using std::string;using std::stringstream;//string类型的时间转换为int型分钟inline int timeToMinute(string aTime)&#123; string::iterator ite = aTime.begin(); int hour, minute; while(ite != aTime.end())&#123; if(*ite == ':')&#123; stringstream hourStream(string(aTime.begin(), ite)); hourStream &gt;&gt; hour; stringstream minuteStream(string(ite + 1, aTime.end())); minuteStream &gt;&gt; minute; return (hour * 60 + minute); &#125; ite++; &#125; return 0;&#125;class Station&#123; public: //有参构造函数 Station(string _stationName = "未命名站点", string _arrivalTime = "", string _leaveTime = "")&#123; stationName = _stationName; arrivalTime = _arrivalTime; leaveTime = _leaveTime; pNextStation = NULL; &#125; //复制构造函数 Station(Station &amp;aStation)&#123; this-&gt;stationName = aStation.stationName; this-&gt;arrivalTime = aStation.arrivalTime; this-&gt;leaveTime = aStation.leaveTime; this-&gt;pNextStation = aStation.pNextStation; &#125; //析构函数 ~Station()&#123;&#125; //重载输出运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Station &amp;aStation)&#123; os &lt;&lt; aStation.stationName &lt;&lt; '\t' &lt;&lt; aStation.arrivalTime &lt;&lt; '\t' &lt;&lt; aStation.leaveTime; return os; &#125; //计算此站出发到下站抵达经历的时间 int calTime()&#123; if(this-&gt;pNextStation == NULL)&#123; return 0; &#125; else &#123; int duringTime = timeToMinute(this-&gt;pNextStation-&gt;arrivalTime) - timeToMinute(this-&gt;leaveTime); return (duringTime &gt; 0) ? duringTime : duringTime + 24 * 60; &#125; &#125; string stationName; //站名 string arrivalTime; //到达时间 string leaveTime; //出发时间 Station* pNextStation; //下一个站点&#125;; train.h12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma once#include "station.h"#include &lt;vector&gt;using std::vector;class Train&#123; public: //构造函数 Train(string _trainName = "未命名列车")&#123; trainName = _trainName; stationNum = 0; headStation = NULL; pNextTrain = NULL; &#125; //析构函数 ~Train(); //添加站点 void insertStation(int locate, string _stationName = "未命名站点", string _arrivalTime = "未定义时间", string _leaveTime = "未定义时间"); //键盘添加站点 void keyboardInsertStation(); //删除站点 void deleteStation(); //改变站点信息 void changeStation(); //根据站点名称查询站点信息 void searchStationForName(); //打印该列车经过所有站点信息 void showAllStation(); //求列车经过站点个数 int getLength(); //重载运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Train &amp;aTrain); //更新运行里程和时间 void updateInfo(); string trainName; //列车车次 int stationNum; //站点个数 Station* headStation; //头站点 Train* pNextTrain; //下一列列车 //vector &lt;int&gt; mileag; //运行里程 vector &lt;int&gt; time; //运行时间&#125;; train.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include "train.h"#include &lt;iostream&gt;using std::cout;using std::endl;using std::cin;//更新运行里程和时间void Train::updateInfo()&#123; Station *myStation = this-&gt;headStation; //清空容器 this-&gt;time.clear(); while(myStation)&#123; //插入时间 this-&gt;time.push_back(myStation-&gt;calTime()); myStation = myStation-&gt;pNextStation; &#125;&#125;//重载运算符ostream &amp; operator&lt;&lt;(ostream &amp;os, const Train &amp;aTrain) &#123; Station *p = aTrain.headStation; while(p)&#123; os &lt;&lt; aTrain.trainName &lt;&lt; '\t' &lt;&lt; *p &lt;&lt; '\t' &lt;&lt; p-&gt;calTime() &lt;&lt;endl; p = p-&gt;pNextStation; &#125; return os;&#125;//求列车站点长度int Train::getLength()&#123; return this-&gt;stationNum;&#125;//添加站点void Train::insertStation(int locate, string _stationName, string _arrivalTime, string _leaveTime)&#123; if (locate &gt; this-&gt;stationNum + 1 || locate &lt; 1) &#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; &#125; else if (this-&gt;headStation != NULL &amp;&amp; locate &gt; 1) &#123; //new一个新站 Station* aStation = new Station(_stationName, _arrivalTime, _leaveTime); //将新站加入列车行程表中 Station* p = this-&gt;headStation; while (locate - 2) &#123; p = p-&gt;pNextStation; locate--; &#125; aStation-&gt;pNextStation = p-&gt;pNextStation; p-&gt;pNextStation = aStation; this-&gt;stationNum++; this-&gt;updateInfo(); cout &lt;&lt; "加入新站成功！" &lt;&lt; endl; &#125; else if (this-&gt;headStation != NULL &amp;&amp; locate == 1)&#123; //new一个新站 Station* aStation = new Station(_stationName, _arrivalTime, _leaveTime); //将新站加入列车行程表中 Station* p = this-&gt;headStation; this-&gt;headStation = aStation; aStation-&gt;pNextStation = p; this-&gt;stationNum++; this-&gt;updateInfo(); cout &lt;&lt; "加入新站成功！" &lt;&lt; endl; &#125; else &#123; //new一个新站 Station* aStation = new Station(_stationName, _arrivalTime, _leaveTime); //将新站加入列车行程表中 this-&gt;headStation = aStation; this-&gt;stationNum++; this-&gt;updateInfo(); cout &lt;&lt; "加入新站成功！" &lt;&lt; endl; &#125;&#125;//键盘增加站点void Train::keyboardInsertStation()&#123; int locate; cout &lt;&lt; "请输入插入的位置："; cin &gt;&gt; locate; string _stationName, _arrivalTime, _leaveTime; cout &lt;&lt; "请分别输入 站点名称 到达时间 出发时间 ：" &lt;&lt; endl; cin &gt;&gt; _stationName &gt;&gt; _arrivalTime &gt;&gt; _leaveTime; this-&gt;insertStation(locate, _stationName, _arrivalTime, _leaveTime);&#125;//删除站点void Train::deleteStation()&#123; int locate; cout &lt;&lt; "请输入插入的位置："; cin &gt;&gt; locate; if(locate &gt; this-&gt;stationNum || locate &lt; 1)&#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; &#125;else if(this-&gt;headStation != NULL &amp;&amp; locate &gt; 1)&#123; Station* p = this-&gt;headStation; while(locate - 2)&#123; //到达第i-1个结点，p-&gt;pNextStation为欲删除的结点的指针 p = p-&gt;pNextStation; locate--; &#125; Station* q = p-&gt;pNextStation; p-&gt;pNextStation = p-&gt;pNextStation-&gt;pNextStation; delete q; this-&gt;stationNum--; this-&gt;updateInfo(); cout &lt;&lt; "删除站点完成！" &lt;&lt; endl; &#125; else if(this-&gt;headStation != NULL &amp;&amp; locate == 1)&#123; Station* p = this-&gt;headStation; this-&gt;headStation = p-&gt;pNextStation; delete p; this-&gt;stationNum--; this-&gt;updateInfo(); cout &lt;&lt; "删除站点完成！" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "列车站台为空！" &lt;&lt; endl; &#125;&#125;//析构函数Train::~Train()&#123; if(this-&gt;headStation == NULL)&#123; &#125; else&#123; Station* p = this-&gt;headStation; Station* q; while (p)&#123; q = p; p = p-&gt;pNextStation; delete q; &#125; &#125;&#125;//改变站点信息void Train::changeStation()&#123; int locate; cout &lt;&lt; "请输入需要改变站台所在的位置："; cin &gt;&gt; locate; if(locate &gt; this-&gt;stationNum || locate &lt; 1)&#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; return; &#125;else&#123; Station* p = this-&gt;headStation; while(locate - 1)&#123; p = p-&gt;pNextStation; locate--; &#125; cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; "1. 站点名称\n2. 列车到达时间\n3. 列车出发时间\n"; cout &lt;&lt; "站点已找到，请选择改变的信息："; int choose; string changeValue; cin &gt;&gt; choose; switch(choose)&#123; case 1: cout &lt;&lt; "请输入新的站名："; cin &gt;&gt; changeValue; p-&gt;stationName = changeValue; cout &lt;&lt; "修改完成！" &lt;&lt; endl; break; case 2: cout &lt;&lt; "请输入新的到达时间："; cin &gt;&gt; changeValue; p-&gt;arrivalTime = changeValue; cout &lt;&lt; "修改完成！" &lt;&lt; endl; this-&gt;updateInfo(); break; case 3: cout &lt;&lt; "请输入新的出发时间："; cin &gt;&gt; changeValue; p-&gt;leaveTime = changeValue; cout &lt;&lt; "修改完成！" &lt;&lt; endl; this-&gt;updateInfo(); break; default: cout &lt;&lt; "未更改数据，请输入正确的数字！" &lt;&lt; endl; &#125; &#125;&#125;//根据站点名称查询站点信息void Train::searchStationForName() &#123; string _stationName; cout &lt;&lt; "请输入要查询的站名：" ; cin &gt;&gt; _stationName; Station* p = this-&gt;headStation; if (p == NULL) &#123; cout &lt;&lt; "行程表为空！" &lt;&lt; endl; &#125; int count = 1; //计数器 while (p) &#123; if (p-&gt;stationName == _stationName) &#123; cout &lt;&lt; "该站点为行程表第" &lt;&lt; count &lt;&lt; "个站点\n站点名称为：" &lt;&lt; p-&gt;stationName &lt;&lt; "\n列车到达时间为：" &lt;&lt; p-&gt;arrivalTime &lt;&lt; "\n列车出发时间为：" &lt;&lt; p-&gt;leaveTime &lt;&lt; endl; &#125; count++; p = p-&gt;pNextStation; &#125; cout &lt;&lt; "未找到该站点的信息！" &lt;&lt; endl;&#125;//打印该列车所有站点void Train::showAllStation() &#123; cout &lt;&lt; this-&gt;trainName &lt;&lt; " 的行程表为：" &lt;&lt; endl; cout &lt;&lt; "列车信息 站点名称 到站时间 出发时间 到达下站所需时间(min)" &lt;&lt; endl; cout &lt;&lt; *this &lt;&lt; endl;&#125; schedule.h12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma once#include "train.h"class Schedule&#123; public: //构造函数 Schedule(string _scheduleName = "未命名时刻表")&#123; scheduleName = _scheduleName; trainNum = 0; headTrain = NULL; &#125; //析构函数 ~Schedule(); //添加列车 Train* insertTrain(int locate, string _trainName = "未命名列车"); //键盘添加站点 void keyboardInsertTrain(); //文本添加站点 void txtInsertTrain(string filename); //文本输出站点 void scheduleToTxt(string filename); //删除列车 void deleteTrain(); //改变列车站点信息 void changeTrainStation(); //改变列车名称 void changeTrainName(); //根据列车名称查询站点信息 Train* searchTrainForName(); //打印所有列车经过所有站点信息 void showAllTrain(); //求列车个数 int getLength(); //操作菜单 void operateTheSchedule(); //重载运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Schedule &amp;aSchedule); private: string scheduleName; //列车车次 int trainNum; //站点个数 Train* headTrain; //头站点&#125;; schedule.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#include "schedule.h"#include &lt;iostream&gt;#include &lt;fstream&gt;using std::cout;using std::endl;using std::cin;using std::ifstream;using std::ofstream;//重载运算符ostream &amp; operator&lt;&lt;(ostream &amp;os, const Schedule &amp;aSchedule) &#123; Train *p = aSchedule.headTrain; while (p) &#123; os &lt;&lt; *p; p = p-&gt;pNextTrain; &#125; return os;&#125;//求列车长度int Schedule::getLength()&#123; return this-&gt;trainNum;&#125;//添加列车Train* Schedule::insertTrain(int locate, string _trainName)&#123; if (locate &gt; this-&gt;trainNum + 1 || locate &lt; 1) &#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; return NULL; &#125; else if (this-&gt;headTrain != NULL &amp;&amp; locate &gt; 1) &#123; //new一个新列车 Train* aTrain = new Train(_trainName); //将新列车加入列车行程表中 Train* p = this-&gt;headTrain; while (locate - 2) &#123; p = p-&gt;pNextTrain; locate--; &#125; aTrain-&gt;pNextTrain = p-&gt;pNextTrain; p-&gt;pNextTrain = aTrain; this-&gt;trainNum++; cout &lt;&lt; "加入新列车成功！" &lt;&lt; endl; return aTrain; &#125; else if(this-&gt;headTrain != NULL &amp;&amp; locate == 1)&#123; //new一个新列车 Train* aTrain = new Train(_trainName); //将新列车加入列车行程表中 Train* p = this-&gt;headTrain; this-&gt;headTrain = aTrain; aTrain-&gt;pNextTrain = p; this-&gt;trainNum++; cout &lt;&lt; "加入新列车成功！" &lt;&lt; endl; return aTrain; &#125; else &#123; //new一个新列车 Train* aTrain = new Train(_trainName); //将新站加入列车行程表中 this-&gt;headTrain = aTrain; this-&gt;trainNum++; cout &lt;&lt; "加入新列车成功！" &lt;&lt; endl; return aTrain; &#125;&#125;//键盘增加列车void Schedule::keyboardInsertTrain()&#123; int locate; cout &lt;&lt; "请输入插入的位置："; cin &gt;&gt; locate; string _trainName; cout &lt;&lt; "请输入列车名称：" ; cin &gt;&gt; _trainName; this-&gt;insertTrain(locate, _trainName);&#125;//文本添加站点void Schedule::txtInsertTrain(string filename)&#123; ifstream infile; infile.open(filename + ".txt"); if(!infile)&#123; cout &lt;&lt; "ERROR：打开 " &lt;&lt; filename &lt;&lt; ".txt 文件失败" &lt;&lt; endl; return; &#125; //_lastTrainName用于优化查找速度,但不可用于多次文本输入内存 string _trainName, _stationName, _arrivalTime, _leaveTime, _lastTrainName; if(this-&gt;headTrain == NULL)&#123; _lastTrainName = ""; &#125;else&#123; _lastTrainName = this-&gt;headTrain-&gt;trainName; &#125; while(infile &gt;&gt; _trainName&gt;&gt; _stationName&gt;&gt;_arrivalTime&gt;&gt;_leaveTime)&#123; if(_trainName == _lastTrainName)&#123; Train *p = this-&gt;headTrain; while (p) &#123; if (p-&gt;trainName == _trainName) &#123; p-&gt;insertStation(p-&gt;stationNum+1, _stationName, _arrivalTime, _leaveTime); break; &#125; p = p-&gt;pNextTrain; &#125; &#125; else &#123; Train *p = this-&gt;insertTrain(this-&gt;trainNum+1, _trainName); p-&gt;insertStation(p-&gt;stationNum+1, _stationName, _arrivalTime, _leaveTime); _lastTrainName = _trainName; &#125; &#125; infile.close();&#125;//文本输出信息void Schedule::scheduleToTxt(string filename)&#123; ofstream outfile; outfile.open(filename + ".txt"); if (!outfile) &#123; cout &lt;&lt; "ERROR：打开 " &lt;&lt; filename &lt;&lt; ".txt 文件失败" &lt;&lt; endl; return; &#125; outfile &lt;&lt; *this; outfile.close();&#125;//删除站点void Schedule::deleteTrain()&#123; int locate; cout &lt;&lt; "请输入删除的位置："; cin &gt;&gt; locate; if(locate &gt; this-&gt;trainNum || locate &lt; 1)&#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; &#125;else if(this-&gt;trainNum != NULL &amp;&amp; locate &gt; 1)&#123; Train* p = this-&gt;headTrain; while(locate - 2)&#123; //到达第i-1个结点，p-&gt;pNextTrain为欲删除的结点的指针 p = p-&gt;pNextTrain; locate--; &#125; Train* q = p-&gt;pNextTrain; p-&gt;pNextTrain = p-&gt;pNextTrain-&gt;pNextTrain; //删除列车的站点 while(q-&gt;stationNum)&#123; Station* delSta; delSta = q-&gt;headStation; q-&gt;headStation = q-&gt;headStation-&gt;pNextStation; delete delSta; q-&gt;stationNum--; &#125; //删除列车 delete q; this-&gt;trainNum--; cout &lt;&lt; "删除列车完成！" &lt;&lt; endl; &#125; else if (this-&gt;trainNum != NULL &amp;&amp; locate == 1)&#123; Train* p = this-&gt;headTrain; this-&gt;headTrain = p-&gt;pNextTrain; //删除列车的站点 while (p-&gt;stationNum) &#123; Station* delSta; delSta = p-&gt;headStation; p-&gt;headStation = p-&gt;headStation-&gt;pNextStation; delete delSta; p-&gt;stationNum--; &#125; //删除列车 delete p; this-&gt;trainNum--; cout &lt;&lt; "删除列车完成！" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "行程表为空！" &lt;&lt; endl; &#125;&#125;//析构函数Schedule::~Schedule()&#123; if (this-&gt;headTrain == NULL) &#123; &#125;else &#123; Train* p = this-&gt;headTrain; Train* q; while (p) &#123; q = p; p = p-&gt;pNextTrain; delete q; &#125; &#125;&#125;//改变列车信息void Schedule::changeTrainStation()&#123; Train* p = this-&gt;searchTrainForName(); if(p != NULL)&#123; while (1) &#123; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; cout &lt;&lt; " * 列车查询系统子菜单 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 您现在正在操作 " &lt;&lt; p-&gt;trainName &lt;&lt; " 列车 *" &lt;&lt; endl; cout &lt;&lt; " * 请输入对应功能的数字完成操作 *" &lt;&lt; endl; cout &lt;&lt; " * 1.添加站点信息 *" &lt;&lt; endl; cout &lt;&lt; " * 2.删除站点信息 *" &lt;&lt; endl; cout &lt;&lt; " * 3.修改站点信息 *" &lt;&lt; endl; cout &lt;&lt; " * 0.退出子菜单 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 列车 "&lt;&lt; p-&gt;trainName &lt;&lt; " 现有站台 "&lt;&lt;p-&gt;getLength() &lt;&lt;" 个 *" &lt;&lt; endl; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; int choice; cout &lt;&lt; "请输入您的选项："; cin &gt;&gt; choice; switch (choice) &#123; case 1: p-&gt;keyboardInsertStation(); break; case 2: p-&gt;deleteStation(); break; case 3: p-&gt;changeStation(); break; case 0: return; default: cout &lt;&lt; "输入选项非法！请重新输入！" &lt;&lt; endl; break; &#125; &#125; &#125;&#125;//查询列车具体信息Train* Schedule::searchTrainForName() &#123; string _trainName; cout &lt;&lt; "请输入要查询的列车名：" ; cin &gt;&gt; _trainName; Train* p = this-&gt;headTrain; if (p == NULL) &#123; cout &lt;&lt; "行程表为空！" &lt;&lt; endl; return p; &#125; int count = 1; //计数器 while (p) &#123; if (p-&gt;trainName == _trainName) &#123; cout &lt;&lt; *p &lt;&lt; endl; return p; &#125; count++; p = p-&gt;pNextTrain; &#125; cout &lt;&lt; "未找到该列车的信息！" &lt;&lt; endl; return p;&#125;//改变列车名称void Schedule::changeTrainName()&#123; Train* p = this-&gt;searchTrainForName(); if (p != NULL) &#123; cout &lt;&lt; "列车已找到，请输入新的列车名："; string _trainName; cin &gt;&gt; _trainName; p-&gt;trainName = _trainName; cout &lt;&lt; "修改成功！" &lt;&lt; endl; &#125;&#125;//打印所有列车所有站点void Schedule::showAllTrain() &#123; cout &lt;&lt; this-&gt;scheduleName &lt;&lt; " 的行程表为：" &lt;&lt; endl; cout &lt;&lt; "列车信息\t站点名称\t到站时间\t出发时间" &lt;&lt; endl; cout &lt;&lt; *this;&#125;//操作菜单void Schedule::operateTheSchedule() &#123; while (true) &#123; int choice; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; cout &lt;&lt; " * 列车查询系统 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 请输入对应功能的数字完成操作 *" &lt;&lt; endl; cout &lt;&lt; " * 1.键盘添加列车信息 *" &lt;&lt; endl; cout &lt;&lt; " * 2.文本添加列车信息 *" &lt;&lt; endl; cout &lt;&lt; " * 3.删除列车信息 *" &lt;&lt; endl; cout &lt;&lt; " * 4.修改列车名称信息 *" &lt;&lt; endl; cout &lt;&lt; " * 5.修改列车站点具体信息 *" &lt;&lt; endl; cout &lt;&lt; " * 6.输出行程表信息 *" &lt;&lt; endl; cout &lt;&lt; " * 0.退出系统 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 目前共有" &lt;&lt; this-&gt;getLength() &lt;&lt; "辆列车 *" &lt;&lt; endl; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; cout &lt;&lt; "请输入您的选项："; cin &gt;&gt; choice; switch (choice) &#123; case 1: this-&gt;keyboardInsertTrain(); break; case 2: &#123; cout &lt;&lt; "请输入要打开的文件名："; string filename; cin &gt;&gt; filename; this-&gt;txtInsertTrain(filename); break; &#125; case 3: this-&gt;deleteTrain(); break; case 4: this-&gt;changeTrainName(); break; case 5: this-&gt;changeTrainStation(); break; case 6: this-&gt;showAllTrain(); break; case 0: &#123; cout &lt;&lt; "您需要保存该行程表吗？(Y/N)\t"; char c; cin &gt;&gt; c; if (c == 'Y' || c == 'y') &#123; cout &lt;&lt; "请输入文件名："; string filename; cin &gt;&gt; filename; this-&gt;scheduleToTxt(filename); return; &#125; return; &#125; default: cout &lt;&lt; "输入选项非法！请重新输入！" &lt;&lt; endl; break; &#125; &#125;&#125; main.cpp12345678#include "schedule.h"int main()&#123; Schedule mySchedule("我的行程表"); mySchedule.operateTheSchedule(); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++文件在Html的高亮处理]]></title>
    <url>%2F2018%2F03%2F17%2FC-%E6%96%87%E4%BB%B6%E5%9C%A8Html%E7%9A%84%E9%AB%98%E4%BA%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[编译原理最基础的问题便是词法分析器了。下面是我使用C++语言利用迭代器实现的将C++源码转为HTML文件，并实现HighLight。 （长期更新，直至成熟）（较为成熟，不再更新） 版本记录 V-0.2.1 (20180326) 添加对制表符（\t）的支持。 V-0.2.0 (20180325) 优化搜索算法。 V-0.1.4 (20180324) 支持显示代码行数。 V-0.1.3 (20180323) 添加了对多行注释的高亮显示。 V-0.1.2 (20180322) 添加了对单行注释（//）的高亮显示。 V-0.1.1 (20180318) 完善了部分功能，添加了对部分字符（如&lt;、&gt;、&amp;、”、）的支持以及头文件行的高亮显示。 V-0.1.0 (20180317) 只实现了大致功能，对字符（如&lt;、&gt;等）处理还未完善，其次准确的说，这是按照词读入，并不是字母，当然利用迭代器同理可以实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;//63个保留字const int RESERVEWORDNUM = 63;const string reserveWord[RESERVEWORDNUM] = &#123; "asm", "auto", "bool", "break", "catch", "case", "char", "class", "const", "const_cast", "continue", "default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern", "false", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable", "namespace", "new", "operator", "private", "protected", "public", "register", "register_cast", "return", "short", "signed", "sizeof", "static", "static_cast", "struct", "switch", "template", "this", "throw", "true", "try", "typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void", "wchar_t", "volatile", "while"&#125;;//动态数组vector&lt;string&gt; reserveWordVector(reserveWord, reserveWord + RESERVEWORDNUM);//检测是否是保留字bool isReserveWord(string &amp;word)&#123; vector&lt;string&gt;::iterator itV; itV = find(reserveWordVector.begin(), reserveWordVector.end(), word); if ( itV != reserveWordVector.end() )&#123; return true ; &#125; else &#123; return false ; &#125;&#125;void translate(string filename)&#123; ifstream infile; //输入流对象 infile.open(filename + ".cpp"); ofstream outfile; //输出流对象 outfile.open(filename + ".html"); int line = 0; //记录cpp文件行数 if (!infile &amp;&amp; !outfile)&#123; cout &lt;&lt; "ERROR：打开文件失败！" &lt;&lt; endl; return ; &#125; string aLine; //存放cpp文件一行代码 string::iterator lineIte; //定义行迭代器 //读取一行代码 while (getline(infile, aLine)) &#123; line++; //更新行数 aLine += " "; //每行后添加空白防止迭代器溢出 string aHtmlLine = ""; //html的一行 lineIte = aLine.begin(); //初始化行迭代器指向行首位置 //对该行进行分割，对分割出的字进行检测 while (lineIte != aLine.end())&#123; string word = ""; //存放一个单词 //行迭代器遇到空格或换行符号时停止并截取单词 while (*lineIte != ' ' &amp;&amp; *lineIte != aLine.back())&#123; //针对html语法，对字符串的处理 if (*lineIte == '&lt;') &#123; word += "&amp;lt;"; &#125; else if (*lineIte == '&gt;') &#123; word += "&amp;gt;"; &#125; else if (*lineIte == '&amp;') &#123; word += "&amp;amp;"; &#125; else if (*lineIte == '\"') &#123; word += "&amp;quot;"; &#125; else if (*lineIte == '\t') &#123; aHtmlLine += " &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "; &#125; //处理缩进问题 else &#123; word += *lineIte; &#125; lineIte++; &#125; //检测单行注释 if (*word.begin() == '/' &amp;&amp; *(word.begin() + 1) == '/') &#123; word = "&lt;font color=\"yellow\"&gt;&lt;b&gt;" + word + "&lt;/b&gt;&lt;/font&gt;"; //注释为黄色 &#125; //检测多行注释 if (*word.begin() == '/' &amp;&amp; *(word.begin() + 1) == '*') &#123; word = "&lt;font color=\"yellow\"&gt;&lt;b&gt;" + word ; //注释为黄色 &#125; if (*word.rbegin() == '/' &amp;&amp; *(word.rbegin() + 1) == '*') &#123; word = word + "&lt;/b&gt;&lt;/font&gt;"; &#125; //检测是否是保留字 if (isReserveWord(word)) &#123; aHtmlLine += "&lt;font color=\"blue\"&gt;&lt;b&gt;" + word + "&lt;/b&gt;&lt;/font&gt;"; //加粗保留字并设置为蓝色 &#125; else &#123; aHtmlLine += word; //其他字不做处理 &#125; if (*lineIte == ' ') &#123; lineIte++; aHtmlLine += " "; &#125; &#125; //检测是否是头文件行 if (*aLine.begin() == '#') &#123; aHtmlLine = "&lt;font color=\"green\"&gt;&lt;b&gt;" + aHtmlLine + "&lt;/b&gt;&lt;/font&gt;"; //头文件行变绿色 &#125; outfile &lt;&lt; "&lt;font color=\"black\"&gt;&lt;b&gt;" &lt;&lt; setw(4) &lt;&lt; setfill('0') &lt;&lt; line &lt;&lt; "&lt;/b&gt;&lt;/font&gt;&amp;sdot; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;" + aHtmlLine + "&lt;br/&gt;" &lt;&lt; endl; //写入.html文件 &#125; infile.close(); //关闭文件流 outfile.close(); //关闭文件流 cout &lt;&lt; "转换成功！" &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; "请输入您要转换的cpp文件："; string cppFileName; cin &gt;&gt; cppFileName; translate(cppFileName); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扔鸡蛋问题]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Google有一道扔鸡蛋的面试题目： You work in a 100 floor building and you get 2 identical eggs.You need to figure out the highest floor an egg can be dropped without breaking.The question is how many throws you need to make.Find an algorithm that is minimizing number of throws in the worst-case scenario. 这道题的意思大致如下： 情景假设1、你在一个 100层高的大楼里； 2、你有 2个一模一样的鸡蛋； 任务1、弄清楚： 鸡蛋最高可以从几层楼扔下去而不会被摔坏； 2、弄清楚你需要扔几次； 3、 提出一个算法，找出在最坏情况下，扔出鸡蛋而不把鸡蛋摔坏的最少次数； 假设首先，在解题之前，我们要做好几个简单的假设： 2个鸡蛋的脆弱程度是一样的。 如果鸡蛋从N楼扔下来没有碎，那么它从小于N楼扔下来，也不会碎 如果鸡蛋从N楼扔下来碎了，那么它从大于N楼扔下来，也一定会碎 一颗扔出去但没有碎的鸡蛋，可以继续被用于试验。 碎了的鸡蛋将无法再继续试验。 有了这些假设之后，我们就可以解题了。 其实解决这道问题的方法有很多，在此列举一些： 最简单解法最简单的一个方法，就是 将鸡蛋从第一层开始，逐层扔出，看它在哪一层会摔碎。 这个方法虽然可靠，但它可能需要进行很多次尝试。比如，在最差的情况下，它需要尝试的次数是100次。 需要注意的一点是，当你只有一颗鸡蛋时，这个算法是唯一可靠的方法。 所以一旦你打碎了第一颗鸡蛋，手里只剩下最后一颗的时候，你就要开始运用这个算法。 最直观解法这个方法重点，是要 利用好第一颗鸡蛋，最大效率地把100层高楼划分成N个更小数目的区间。 一个比较直观和流行的答案是， 将鸡蛋从【要检查的楼层* 1/N】层开始扔下去，逐层检查。 例如，当N=3时，我们就将第一颗鸡蛋从100*1/3 ≈ 33层楼扔出： ► 如果它破损了，我们就接着用第二颗鸡蛋检验32层楼及以下。 ► 如果它没破损，我们就继续将同一颗鸡蛋从33 + (67 * 1/3) = 55层楼扔出，如果它破了，我们就用第二颗鸡蛋，检验34层 - 55层 …… 当N = 3时，最坏的情况是max(33, 24, …) = 33层。 按照这个思路，再通过dynamic programming，我们就可以找到一个完美的N，来最优化鸡蛋的投掷次数了。 这个解法在面试中还是很有&quot;价值&quot;的，毕竟它能向面试官展现求职者的编程思维。但它还不是最佳解法。 最优解在理解最佳解法之前，我们需要理解以下这个equilibrium（均衡状态）： 这个均衡状态计算的是在最坏情境下，所需的扔鸡蛋次数。这里，F(n)指的是楼层，是我们扔第一个鸡蛋后的下一层。 假如我们引入以下变量： 那么刚刚的equilibrium就变成这样： 当这个函数里的所有参数都相等时，就是我们的最优解。 那么我们如何做到呢？ 从末尾开始看，最后的D(n)将会变成1，因为最终我们将会到达一个点 —— 就是只剩下一层楼可以扔第一颗鸡蛋。 因此，D(n-1)应该等于2。 我们接着会发现，第一颗鸡蛋最终应该是从第99层楼扔出，之前是从99-2=97层，再往前则是97-3=94层，90, 85, 79, 72, 64, 55, 45, 34, 22，然后是第9层。 这就是一个最优解！ 这样一来，我们就得出了答案： 在最坏的情况下，我们需要的扔鸡蛋的最少次数，是14次 （最小的差别在于13，但是我们还需要在第9层额外扔一次）。 检查现在就到了检验我们的解法是否正确的时候了。我们可以编写一个简单的Kotlin程序来检验答案。首先，我们需要解释一下，如何在某些决策中，计算扔鸡蛋次数。当有2层或更少的楼层时，我们需要按照剩余的楼层数，来决定扔鸡蛋的次数。 否则，我们应该调用以下均衡函数： 我们在这里使用了bestMaxThrows函数。这是一个假设的函数，它会返回一个投掷次数的数值，并假设接下来的一系列决策是完美的。 我们是这样定义它的： 同样，我们把&quot;计算下一层最优解&quot;的任务，交给了bestNextStep 函数。这个函数很好的为我们指明了下一步的方向。我们可以这样简单地定义它：当只有二层或更少的楼层待检验时，我们会从第一层扔出鸡蛋。否则，我们需要检查所有备选项，然后找到最优解。 下面是具体执行步骤： 需要注意的是，这个方程用了maxThrows函数，因此会涉及到recurrence （循环）。 但这并不成问题，因为当bestNextStep调用maxThrows时，它始终会使用比floorLeft更小的值调用它（因为nextFloor总是大于0）。 在我们使用它之前，我们需要添加一些缓冲，从而加速计算： 首先，我们可以检查它是否返回与我们计算结果相同的结果： 结果是14 —— 这个结果看上去还不错，我们接着检查之后的几个步骤： Result9, 22, 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, 100, 跟我们计算的结果是一致的! Bigger picture以上分享的这个算法，其实还可以解决许多其他类似的问题。 比如，我们可以把原题的提问改改，改成计算最随机情况下的扔鸡蛋次数。我们还可以看看，当建筑物的高度有变化时，得出的结果是否也会跟着变化。 下图很好地回答了以上问题：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2018%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;2018年2月26日，基于Hexo框架并托管在GitHub服务器上，我建立了第一个自己的博客网站 (https://conglindev.github.io/)&ensp;&ensp;&ensp;&ensp;虽然功能不完善，但是具有了博客的基本的功能。以后我会尽量完善和美化这个网站的。 Hello world!]]></content>
  </entry>
</search>

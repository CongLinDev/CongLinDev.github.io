<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Solutions to problems on LeetCode]]></title>
    <url>%2F2018%2F04%2F05%2FSolutions-to-problems-on-LeetCode%2F</url>
    <content type="text"><![CDATA[分享一些我在LeetCode(https://leetcode.com)的算法收获。 （持续更新） 两数之和 给定一个整数数列，找出其中和为特定值的那两个数。你可以假设每个输入都只会有一种答案，同样的元素不能被重用。 示例：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 123456789101112131415161718192021//C++class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int sum; vector&lt;int&gt; sumVec; for(int i = 0; i &lt; nums.size(); i++)&#123; for(int j = i + 1; j&lt;nums.size(); j++)&#123; sum = nums[i]+nums[j]; if(sum == target)&#123; sumVec.push_back(i); sumVec.push_back(j); return sumVec; &#125; &#125; &#125; return sumVec; &#125;&#125;; 两数相加 给定两个非空链表来代表两个非负整数，位数按照逆序方式存储，它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 12345678910111213141516171819202122232425262728293031323334353637//Java/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy=new ListNode(-1); ListNode cur=dummy; int carry = 0; while((l1 != null)||(l2 != null)) &#123; //要注意两个链表的长度不同的情况，当链表为null时，设置为零 int d1=(l1==null? 0:l1.val); int d2=(l2==null? 0:l2.val); int sum=d1 + d2 + carry; //carry=sum/10; carry=sum&gt;=10? 1:0; cur.next=new ListNode(sum%10); cur=cur.next; //null无法链接next if(l1 != null) &#123; l1=l1.next; &#125; if(l2 != null) &#123; l2=l2.next; &#125; &#125; if(carry &gt; 0) &#123; cur.next=new ListNode(carry); &#125; return dummy.next; &#125;&#125; 无重复字符的最长子串 给定一个字符串，找出不含有重复字符的最长子串的长度。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例：给定&quot;abcabcbb&quot;，没有重复字符的最长子串是&quot;abc&quot;，那么长度就是3。给定&quot;bbbbb&quot;，最长的子串就是&quot;b&quot;，长度是1。给定&quot;pwwkew&quot;，最长子串是&quot;wke&quot;，长度是3。请注意答案必须是一个子串，&quot;pwke&quot;是子序列而不是子串。 123456789101112131415161718192021//Javapublic class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int res = 0; //记录结果 int len = 0; //记录长度 int start = 0; //记录开始索引 for(int i = 0; i &lt; s.length(); i++)&#123; if(map.containsKey(s.charAt(i)) &amp;&amp; map.get(s.charAt(i)) &gt;= start)&#123; start = map.get(s.charAt(i)) + 1; &#125; len = i - start + 1; //记录长度 map.put(s.charAt(i),i); res = Math.max(res,len); //记录最大值 &#125; return res; &#125;&#125; 两个排序数组的中位数 有两个大小为 m 和 n 的排序数组nums1和nums2。请找出两个排序数组的中位数并且总的运行时间复杂度为 O(log (m+n))。 示例1：nums1 = [1, 3]nums2 = [2]中位数是 2.0 示例2:nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Java/*题目要求O(log(m+n))的时间复杂度，一般来说都是分治法或者二分搜索。首先我们先分析下题目，假设两个有序序列共有n个元素（根据中位数的定义我们要分两种情况考虑），当n为奇数时，搜寻第(n/2+1)个元素，当n为偶数时，搜寻第(n/2+1)和第(n/2)个元素，然后取他们的均值。进一步的，我们可以把这题抽象为“搜索两个有序序列的第k个元素”。如果我们解决了这个k元素问题，那中位数不过是k的取值不同罢了。假设序列都是从小到大排列，对于第一个序列中前p个元素和第二个序列中前q个元素，我们想要的最终结果是：p+q等于k-1,且一序列第p个元素和二序列第q个元素都小于总序列第k个元素。因为总序列中，必然有k-1个元素小于等于第k个元素。这样第p+1个元素或者第q+1个元素就是我们要找的第k个元素。所以，我们可以通过二分法将问题规模缩小，假设p=k/2-1，则q=k-p-1，且p+q=k-1。如果第一个序列第p个元素小于第二个序列第q个元素，我们不确定二序列第q个元素是大了还是小了，但一序列的前p个元素肯定都小于目标，所以我们将第一个序列前p个元素全部抛弃，形成一个较短的新序列。然后，用新序列替代原先的第一个序列，再找其中的第k-p个元素（因为我们已经排除了p个元素，k需要更新为k-p），依次递归。同理，如果第一个序列第p个元素大于第二个序列第q个元素，我们则抛弃第二个序列的前q个元素。递归的终止条件有如下几种：较短序列所有元素都被抛弃，则返回较长序列的第k个元素（在数组中下标是k-1），一序列第p个元素等于二序列第q个元素，此时总序列第p+q=k-1个元素的后一个元素，也就是总序列的第k个元素注意每次递归不仅要更新数组起始位置（起始位置之前的元素被抛弃），也要更新k的大小（扣除被抛弃的元素）*/class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len1 = nums1.length; int len2 = nums2.length; int k = (len1 + len2) / 2; if((len1 + len2) % 2 != 0)&#123; return findKth(nums1, nums2, 0, 0, len1, len2, k + 1); &#125; else &#123; return (findKth(nums1,nums2,0,0,len1,len2,k)+findKth(nums1,nums2,0,0,len1,len2,k+1))/2; &#125; &#125; //通过二分法将问题规模缩小,找出arr1和arr2中第k个元素，默认arr1长度小于等于arr2 public double findKth(int[] arr1, int[]arr2, int start1, int start2, int len1, int len2, int k)&#123; if(len1 &gt; len2)&#123; return findKth(arr2, arr1, start2, start1, len2, len1, k); &#125; if(len1 == 0)&#123; return arr2[start2 + k - 1]; &#125; if(k == 1)&#123; return Math.min(arr1[start1], arr2[start2]); &#125; //假设p=k/2-1，则q=k-p-1 int p = Math.min(k/2, len1); int q = k - p; if(arr1[start1 + p - 1] &lt; arr2[start2 + q - 1])&#123; return findKth(arr1, arr2, start1 + p, start2, len1 - p, len2, k - p); &#125;else if(arr1[start1 + p - 1] &gt; arr2[start2 + q - 1])&#123; return findKth(arr1, arr2, start1, start2 + q, len1, len2 - q, k - q); &#125; else &#123; return arr1[start1 + p - 1]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表实现简单列车查询系统]]></title>
    <url>%2F2018%2F03%2F31%2F%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%88%97%E8%BD%A6%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[利用C++链表知识实现简单的列车查询系统。 设计目的综合运用链表知识解决实际问题的能力。 设计内容设计火车售票处的计算机系统，可以为客户提供下列各项服务： 查询列车信息：根据旅客提出的起始站和终点站名，或者列车车次，输出下列信息：列车车次、发车时刻、到达时刻、运行时间，以及每个途经站点的站名、到达时间、发车时间、运行里程等信息； 录入列车信息； 修改列车信息； 删除列车信息； 浏览所有列车信息； 其它必要功能。 设计要求 要求采用链表方式存储所有列车车次基本信息（如车次名称等），对于其中的每个列车车次，也采用链表方式存储各个途经站点信息； 能够支持查询、修改、增加、删除等信息； 如有时间，建议提供保存和打开功能，用户可以把所有信息保存到硬盘文件上，也可以从硬盘文件上读取信息； 界面友好。 代码实现station.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#pragma once#include &lt;string&gt;#include &lt;sstream&gt;using std::ostream;using std::string;using std::stringstream;//string类型的时间转换为int型分钟inline int timeToMinute(string aTime)&#123; string::iterator ite = aTime.begin(); int hour, minute; while(ite != aTime.end())&#123; if(*ite == ':')&#123; stringstream hourStream(string(aTime.begin(), ite)); hourStream &gt;&gt; hour; stringstream minuteStream(string(ite + 1, aTime.end())); minuteStream &gt;&gt; minute; return (hour * 60 + minute); &#125; ite++; &#125; return 0;&#125;class Station&#123; public: //有参构造函数 Station(string _stationName = "未命名站点", string _arrivalTime = "", string _leaveTime = "")&#123; stationName = _stationName; arrivalTime = _arrivalTime; leaveTime = _leaveTime; pNextStation = NULL; &#125; //复制构造函数 Station(Station &amp;aStation)&#123; this-&gt;stationName = aStation.stationName; this-&gt;arrivalTime = aStation.arrivalTime; this-&gt;leaveTime = aStation.leaveTime; this-&gt;pNextStation = aStation.pNextStation; &#125; //析构函数 ~Station()&#123;&#125; //重载输出运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Station &amp;aStation)&#123; os &lt;&lt; aStation.stationName &lt;&lt; '\t' &lt;&lt; aStation.arrivalTime &lt;&lt; '\t' &lt;&lt; aStation.leaveTime; return os; &#125; //计算此站出发到下站抵达经历的时间 int calTime()&#123; if(this-&gt;pNextStation == NULL)&#123; return 0; &#125; else &#123; int duringTime = timeToMinute(this-&gt;pNextStation-&gt;arrivalTime) - timeToMinute(this-&gt;leaveTime); return (duringTime &gt; 0) ? duringTime : duringTime + 24 * 60; &#125; &#125; string stationName; //站名 string arrivalTime; //到达时间 string leaveTime; //出发时间 Station* pNextStation; //下一个站点&#125;; train.h12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma once#include "station.h"#include &lt;vector&gt;using std::vector;class Train&#123; public: //构造函数 Train(string _trainName = "未命名列车")&#123; trainName = _trainName; stationNum = 0; headStation = NULL; pNextTrain = NULL; &#125; //析构函数 ~Train(); //添加站点 void insertStation(int locate, string _stationName = "未命名站点", string _arrivalTime = "未定义时间", string _leaveTime = "未定义时间"); //键盘添加站点 void keyboardInsertStation(); //删除站点 void deleteStation(); //改变站点信息 void changeStation(); //根据站点名称查询站点信息 void searchStationForName(); //打印该列车经过所有站点信息 void showAllStation(); //求列车经过站点个数 int getLength(); //重载运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Train &amp;aTrain); //更新运行里程和时间 void updateInfo(); string trainName; //列车车次 int stationNum; //站点个数 Station* headStation; //头站点 Train* pNextTrain; //下一列列车 //vector &lt;int&gt; mileag; //运行里程 vector &lt;int&gt; time; //运行时间&#125;; train.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include "train.h"#include &lt;iostream&gt;using std::cout;using std::endl;using std::cin;//更新运行里程和时间void Train::updateInfo()&#123; Station *myStation = this-&gt;headStation; //清空容器 this-&gt;time.clear(); while(myStation)&#123; //插入时间 this-&gt;time.push_back(myStation-&gt;calTime()); myStation = myStation-&gt;pNextStation; &#125;&#125;//重载运算符ostream &amp; operator&lt;&lt;(ostream &amp;os, const Train &amp;aTrain) &#123; Station *p = aTrain.headStation; while(p)&#123; os &lt;&lt; aTrain.trainName &lt;&lt; '\t' &lt;&lt; *p &lt;&lt; '\t' &lt;&lt; p-&gt;calTime() &lt;&lt;endl; p = p-&gt;pNextStation; &#125; return os;&#125;//求列车站点长度int Train::getLength()&#123; return this-&gt;stationNum;&#125;//添加站点void Train::insertStation(int locate, string _stationName, string _arrivalTime, string _leaveTime)&#123; if (locate &gt; this-&gt;stationNum + 1 || locate &lt; 1) &#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; &#125; else if (this-&gt;headStation != NULL &amp;&amp; locate &gt; 1) &#123; //new一个新站 Station* aStation = new Station(_stationName, _arrivalTime, _leaveTime); //将新站加入列车行程表中 Station* p = this-&gt;headStation; while (locate - 2) &#123; p = p-&gt;pNextStation; locate--; &#125; aStation-&gt;pNextStation = p-&gt;pNextStation; p-&gt;pNextStation = aStation; this-&gt;stationNum++; this-&gt;updateInfo(); cout &lt;&lt; "加入新站成功！" &lt;&lt; endl; &#125; else if (this-&gt;headStation != NULL &amp;&amp; locate == 1)&#123; //new一个新站 Station* aStation = new Station(_stationName, _arrivalTime, _leaveTime); //将新站加入列车行程表中 Station* p = this-&gt;headStation; this-&gt;headStation = aStation; aStation-&gt;pNextStation = p; this-&gt;stationNum++; this-&gt;updateInfo(); cout &lt;&lt; "加入新站成功！" &lt;&lt; endl; &#125; else &#123; //new一个新站 Station* aStation = new Station(_stationName, _arrivalTime, _leaveTime); //将新站加入列车行程表中 this-&gt;headStation = aStation; this-&gt;stationNum++; this-&gt;updateInfo(); cout &lt;&lt; "加入新站成功！" &lt;&lt; endl; &#125;&#125;//键盘增加站点void Train::keyboardInsertStation()&#123; int locate; cout &lt;&lt; "请输入插入的位置："; cin &gt;&gt; locate; string _stationName, _arrivalTime, _leaveTime; cout &lt;&lt; "请分别输入 站点名称 到达时间 出发时间 ：" &lt;&lt; endl; cin &gt;&gt; _stationName &gt;&gt; _arrivalTime &gt;&gt; _leaveTime; this-&gt;insertStation(locate, _stationName, _arrivalTime, _leaveTime);&#125;//删除站点void Train::deleteStation()&#123; int locate; cout &lt;&lt; "请输入插入的位置："; cin &gt;&gt; locate; if(locate &gt; this-&gt;stationNum || locate &lt; 1)&#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; &#125;else if(this-&gt;headStation != NULL &amp;&amp; locate &gt; 1)&#123; Station* p = this-&gt;headStation; while(locate - 2)&#123; //到达第i-1个结点，p-&gt;pNextStation为欲删除的结点的指针 p = p-&gt;pNextStation; locate--; &#125; Station* q = p-&gt;pNextStation; p-&gt;pNextStation = p-&gt;pNextStation-&gt;pNextStation; delete q; this-&gt;stationNum--; this-&gt;updateInfo(); cout &lt;&lt; "删除站点完成！" &lt;&lt; endl; &#125; else if(this-&gt;headStation != NULL &amp;&amp; locate == 1)&#123; Station* p = this-&gt;headStation; this-&gt;headStation = p-&gt;pNextStation; delete p; this-&gt;stationNum--; this-&gt;updateInfo(); cout &lt;&lt; "删除站点完成！" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "列车站台为空！" &lt;&lt; endl; &#125;&#125;//析构函数Train::~Train()&#123; if(this-&gt;headStation == NULL)&#123; &#125; else&#123; Station* p = this-&gt;headStation; Station* q; while (p)&#123; q = p; p = p-&gt;pNextStation; delete q; &#125; &#125;&#125;//改变站点信息void Train::changeStation()&#123; int locate; cout &lt;&lt; "请输入需要改变站台所在的位置："; cin &gt;&gt; locate; if(locate &gt; this-&gt;stationNum || locate &lt; 1)&#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; return; &#125;else&#123; Station* p = this-&gt;headStation; while(locate - 1)&#123; p = p-&gt;pNextStation; locate--; &#125; cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; "1. 站点名称\n2. 列车到达时间\n3. 列车出发时间\n"; cout &lt;&lt; "站点已找到，请选择改变的信息："; int choose; string changeValue; cin &gt;&gt; choose; switch(choose)&#123; case 1: cout &lt;&lt; "请输入新的站名："; cin &gt;&gt; changeValue; p-&gt;stationName = changeValue; cout &lt;&lt; "修改完成！" &lt;&lt; endl; break; case 2: cout &lt;&lt; "请输入新的到达时间："; cin &gt;&gt; changeValue; p-&gt;arrivalTime = changeValue; cout &lt;&lt; "修改完成！" &lt;&lt; endl; this-&gt;updateInfo(); break; case 3: cout &lt;&lt; "请输入新的出发时间："; cin &gt;&gt; changeValue; p-&gt;leaveTime = changeValue; cout &lt;&lt; "修改完成！" &lt;&lt; endl; this-&gt;updateInfo(); break; default: cout &lt;&lt; "未更改数据，请输入正确的数字！" &lt;&lt; endl; &#125; &#125;&#125;//根据站点名称查询站点信息void Train::searchStationForName() &#123; string _stationName; cout &lt;&lt; "请输入要查询的站名：" ; cin &gt;&gt; _stationName; Station* p = this-&gt;headStation; if (p == NULL) &#123; cout &lt;&lt; "行程表为空！" &lt;&lt; endl; &#125; int count = 1; //计数器 while (p) &#123; if (p-&gt;stationName == _stationName) &#123; cout &lt;&lt; "该站点为行程表第" &lt;&lt; count &lt;&lt; "个站点\n站点名称为：" &lt;&lt; p-&gt;stationName &lt;&lt; "\n列车到达时间为：" &lt;&lt; p-&gt;arrivalTime &lt;&lt; "\n列车出发时间为：" &lt;&lt; p-&gt;leaveTime &lt;&lt; endl; &#125; count++; p = p-&gt;pNextStation; &#125; cout &lt;&lt; "未找到该站点的信息！" &lt;&lt; endl;&#125;//打印该列车所有站点void Train::showAllStation() &#123; cout &lt;&lt; this-&gt;trainName &lt;&lt; " 的行程表为：" &lt;&lt; endl; cout &lt;&lt; "列车信息 站点名称 到站时间 出发时间 到达下站所需时间(min)" &lt;&lt; endl; cout &lt;&lt; *this &lt;&lt; endl;&#125; schedule.h12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma once#include "train.h"class Schedule&#123; public: //构造函数 Schedule(string _scheduleName = "未命名时刻表")&#123; scheduleName = _scheduleName; trainNum = 0; headTrain = NULL; &#125; //析构函数 ~Schedule(); //添加列车 Train* insertTrain(int locate, string _trainName = "未命名列车"); //键盘添加站点 void keyboardInsertTrain(); //文本添加站点 void txtInsertTrain(string filename); //文本输出站点 void scheduleToTxt(string filename); //删除列车 void deleteTrain(); //改变列车站点信息 void changeTrainStation(); //改变列车名称 void changeTrainName(); //根据列车名称查询站点信息 Train* searchTrainForName(); //打印所有列车经过所有站点信息 void showAllTrain(); //求列车个数 int getLength(); //操作菜单 void operateTheSchedule(); //重载运算符 friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Schedule &amp;aSchedule); private: string scheduleName; //列车车次 int trainNum; //站点个数 Train* headTrain; //头站点&#125;; schedule.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#include "schedule.h"#include &lt;iostream&gt;#include &lt;fstream&gt;using std::cout;using std::endl;using std::cin;using std::ifstream;using std::ofstream;//重载运算符ostream &amp; operator&lt;&lt;(ostream &amp;os, const Schedule &amp;aSchedule) &#123; Train *p = aSchedule.headTrain; while (p) &#123; os &lt;&lt; *p; p = p-&gt;pNextTrain; &#125; return os;&#125;//求列车长度int Schedule::getLength()&#123; return this-&gt;trainNum;&#125;//添加列车Train* Schedule::insertTrain(int locate, string _trainName)&#123; if (locate &gt; this-&gt;trainNum + 1 || locate &lt; 1) &#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; return NULL; &#125; else if (this-&gt;headTrain != NULL &amp;&amp; locate &gt; 1) &#123; //new一个新列车 Train* aTrain = new Train(_trainName); //将新列车加入列车行程表中 Train* p = this-&gt;headTrain; while (locate - 2) &#123; p = p-&gt;pNextTrain; locate--; &#125; aTrain-&gt;pNextTrain = p-&gt;pNextTrain; p-&gt;pNextTrain = aTrain; this-&gt;trainNum++; cout &lt;&lt; "加入新列车成功！" &lt;&lt; endl; return aTrain; &#125; else if(this-&gt;headTrain != NULL &amp;&amp; locate == 1)&#123; //new一个新列车 Train* aTrain = new Train(_trainName); //将新列车加入列车行程表中 Train* p = this-&gt;headTrain; this-&gt;headTrain = aTrain; aTrain-&gt;pNextTrain = p; this-&gt;trainNum++; cout &lt;&lt; "加入新列车成功！" &lt;&lt; endl; return aTrain; &#125; else &#123; //new一个新列车 Train* aTrain = new Train(_trainName); //将新站加入列车行程表中 this-&gt;headTrain = aTrain; this-&gt;trainNum++; cout &lt;&lt; "加入新列车成功！" &lt;&lt; endl; return aTrain; &#125;&#125;//键盘增加列车void Schedule::keyboardInsertTrain()&#123; int locate; cout &lt;&lt; "请输入插入的位置："; cin &gt;&gt; locate; string _trainName; cout &lt;&lt; "请输入列车名称：" ; cin &gt;&gt; _trainName; this-&gt;insertTrain(locate, _trainName);&#125;//文本添加站点void Schedule::txtInsertTrain(string filename)&#123; ifstream infile; infile.open(filename + ".txt"); if(!infile)&#123; cout &lt;&lt; "ERROR：打开 " &lt;&lt; filename &lt;&lt; ".txt 文件失败" &lt;&lt; endl; return; &#125; //_lastTrainName用于优化查找速度,但不可用于多次文本输入内存 string _trainName, _stationName, _arrivalTime, _leaveTime, _lastTrainName; if(this-&gt;headTrain == NULL)&#123; _lastTrainName = ""; &#125;else&#123; _lastTrainName = this-&gt;headTrain-&gt;trainName; &#125; while(infile &gt;&gt; _trainName&gt;&gt; _stationName&gt;&gt;_arrivalTime&gt;&gt;_leaveTime)&#123; if(_trainName == _lastTrainName)&#123; Train *p = this-&gt;headTrain; while (p) &#123; if (p-&gt;trainName == _trainName) &#123; p-&gt;insertStation(p-&gt;stationNum+1, _stationName, _arrivalTime, _leaveTime); break; &#125; p = p-&gt;pNextTrain; &#125; &#125; else &#123; Train *p = this-&gt;insertTrain(this-&gt;trainNum+1, _trainName); p-&gt;insertStation(p-&gt;stationNum+1, _stationName, _arrivalTime, _leaveTime); _lastTrainName = _trainName; &#125; &#125; infile.close();&#125;//文本输出信息void Schedule::scheduleToTxt(string filename)&#123; ofstream outfile; outfile.open(filename + ".txt"); if (!outfile) &#123; cout &lt;&lt; "ERROR：打开 " &lt;&lt; filename &lt;&lt; ".txt 文件失败" &lt;&lt; endl; return; &#125; outfile &lt;&lt; *this; outfile.close();&#125;//删除站点void Schedule::deleteTrain()&#123; int locate; cout &lt;&lt; "请输入删除的位置："; cin &gt;&gt; locate; if(locate &gt; this-&gt;trainNum || locate &lt; 1)&#123; cout &lt;&lt; "ERROR:超出行程表范围！" &lt;&lt; endl; &#125;else if(this-&gt;trainNum != NULL &amp;&amp; locate &gt; 1)&#123; Train* p = this-&gt;headTrain; while(locate - 2)&#123; //到达第i-1个结点，p-&gt;pNextTrain为欲删除的结点的指针 p = p-&gt;pNextTrain; locate--; &#125; Train* q = p-&gt;pNextTrain; p-&gt;pNextTrain = p-&gt;pNextTrain-&gt;pNextTrain; //删除列车的站点 while(q-&gt;stationNum)&#123; Station* delSta; delSta = q-&gt;headStation; q-&gt;headStation = q-&gt;headStation-&gt;pNextStation; delete delSta; q-&gt;stationNum--; &#125; //删除列车 delete q; this-&gt;trainNum--; cout &lt;&lt; "删除列车完成！" &lt;&lt; endl; &#125; else if (this-&gt;trainNum != NULL &amp;&amp; locate == 1)&#123; Train* p = this-&gt;headTrain; this-&gt;headTrain = p-&gt;pNextTrain; //删除列车的站点 while (p-&gt;stationNum) &#123; Station* delSta; delSta = p-&gt;headStation; p-&gt;headStation = p-&gt;headStation-&gt;pNextStation; delete delSta; p-&gt;stationNum--; &#125; //删除列车 delete p; this-&gt;trainNum--; cout &lt;&lt; "删除列车完成！" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "行程表为空！" &lt;&lt; endl; &#125;&#125;//析构函数Schedule::~Schedule()&#123; if (this-&gt;headTrain == NULL) &#123; &#125;else &#123; Train* p = this-&gt;headTrain; Train* q; while (p) &#123; q = p; p = p-&gt;pNextTrain; delete q; &#125; &#125;&#125;//改变列车信息void Schedule::changeTrainStation()&#123; Train* p = this-&gt;searchTrainForName(); if(p != NULL)&#123; while (1) &#123; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; cout &lt;&lt; " * 列车查询系统子菜单 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 您现在正在操作 " &lt;&lt; p-&gt;trainName &lt;&lt; " 列车 *" &lt;&lt; endl; cout &lt;&lt; " * 请输入对应功能的数字完成操作 *" &lt;&lt; endl; cout &lt;&lt; " * 1.添加站点信息 *" &lt;&lt; endl; cout &lt;&lt; " * 2.删除站点信息 *" &lt;&lt; endl; cout &lt;&lt; " * 3.修改站点信息 *" &lt;&lt; endl; cout &lt;&lt; " * 0.退出子菜单 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 列车 "&lt;&lt; p-&gt;trainName &lt;&lt; " 现有站台 "&lt;&lt;p-&gt;getLength() &lt;&lt;" 个 *" &lt;&lt; endl; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; int choice; cout &lt;&lt; "请输入您的选项："; cin &gt;&gt; choice; switch (choice) &#123; case 1: p-&gt;keyboardInsertStation(); break; case 2: p-&gt;deleteStation(); break; case 3: p-&gt;changeStation(); break; case 0: return; default: cout &lt;&lt; "输入选项非法！请重新输入！" &lt;&lt; endl; break; &#125; &#125; &#125;&#125;//查询列车具体信息Train* Schedule::searchTrainForName() &#123; string _trainName; cout &lt;&lt; "请输入要查询的列车名：" ; cin &gt;&gt; _trainName; Train* p = this-&gt;headTrain; if (p == NULL) &#123; cout &lt;&lt; "行程表为空！" &lt;&lt; endl; return p; &#125; int count = 1; //计数器 while (p) &#123; if (p-&gt;trainName == _trainName) &#123; cout &lt;&lt; *p &lt;&lt; endl; return p; &#125; count++; p = p-&gt;pNextTrain; &#125; cout &lt;&lt; "未找到该列车的信息！" &lt;&lt; endl; return p;&#125;//改变列车名称void Schedule::changeTrainName()&#123; Train* p = this-&gt;searchTrainForName(); if (p != NULL) &#123; cout &lt;&lt; "列车已找到，请输入新的列车名："; string _trainName; cin &gt;&gt; _trainName; p-&gt;trainName = _trainName; cout &lt;&lt; "修改成功！" &lt;&lt; endl; &#125;&#125;//打印所有列车所有站点void Schedule::showAllTrain() &#123; cout &lt;&lt; this-&gt;scheduleName &lt;&lt; " 的行程表为：" &lt;&lt; endl; cout &lt;&lt; "列车信息\t站点名称\t到站时间\t出发时间" &lt;&lt; endl; cout &lt;&lt; *this;&#125;//操作菜单void Schedule::operateTheSchedule() &#123; while (true) &#123; int choice; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; cout &lt;&lt; " * 列车查询系统 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 请输入对应功能的数字完成操作 *" &lt;&lt; endl; cout &lt;&lt; " * 1.键盘添加列车信息 *" &lt;&lt; endl; cout &lt;&lt; " * 2.文本添加列车信息 *" &lt;&lt; endl; cout &lt;&lt; " * 3.删除列车信息 *" &lt;&lt; endl; cout &lt;&lt; " * 4.修改列车名称信息 *" &lt;&lt; endl; cout &lt;&lt; " * 5.修改列车站点具体信息 *" &lt;&lt; endl; cout &lt;&lt; " * 6.输出行程表信息 *" &lt;&lt; endl; cout &lt;&lt; " * 0.退出系统 *" &lt;&lt; endl; cout &lt;&lt; " * *" &lt;&lt; endl; cout &lt;&lt; " * 目前共有" &lt;&lt; this-&gt;getLength() &lt;&lt; "辆列车 *" &lt;&lt; endl; cout &lt;&lt; " ******************************************************" &lt;&lt; endl; cout &lt;&lt; "请输入您的选项："; cin &gt;&gt; choice; switch (choice) &#123; case 1: this-&gt;keyboardInsertTrain(); break; case 2: &#123; cout &lt;&lt; "请输入要打开的文件名："; string filename; cin &gt;&gt; filename; this-&gt;txtInsertTrain(filename); break; &#125; case 3: this-&gt;deleteTrain(); break; case 4: this-&gt;changeTrainName(); break; case 5: this-&gt;changeTrainStation(); break; case 6: this-&gt;showAllTrain(); break; case 0: &#123; cout &lt;&lt; "您需要保存该行程表吗？(Y/N)\t"; char c; cin &gt;&gt; c; if (c == 'Y' || c == 'y') &#123; cout &lt;&lt; "请输入文件名："; string filename; cin &gt;&gt; filename; this-&gt;scheduleToTxt(filename); return; &#125; return; &#125; default: cout &lt;&lt; "输入选项非法！请重新输入！" &lt;&lt; endl; break; &#125; &#125;&#125; main.cpp12345678#include "schedule.h"int main()&#123; Schedule mySchedule("我的行程表"); mySchedule.operateTheSchedule(); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++文件在Html的高亮处理]]></title>
    <url>%2F2018%2F03%2F17%2FC-%E6%96%87%E4%BB%B6%E5%9C%A8Html%E7%9A%84%E9%AB%98%E4%BA%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[编译原理最基础的问题便是词法分析器了。下面是我使用C++语言利用迭代器实现的将C++源码转为HTML文件，并实现HighLight。 （长期更新，直至成熟）（较为成熟，不再更新） 版本记录 V-0.2.1 (20180326) 添加对制表符（\t）的支持。 V-0.2.0 (20180325) 优化搜索算法。 V-0.1.4 (20180324) 支持显示代码行数。 V-0.1.3 (20180323) 添加了对多行注释的高亮显示。 V-0.1.2 (20180322) 添加了对单行注释（//）的高亮显示。 V-0.1.1 (20180318) 完善了部分功能，添加了对部分字符（如&lt;、&gt;、&amp;、”、）的支持以及头文件行的高亮显示。 V-0.1.0 (20180317) 只实现了大致功能，对字符（如&lt;、&gt;等）处理还未完善，其次准确的说，这是按照词读入，并不是字母，当然利用迭代器同理可以实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;//63个保留字const int RESERVEWORDNUM = 63;const string reserveWord[RESERVEWORDNUM] = &#123; "asm", "auto", "bool", "break", "catch", "case", "char", "class", "const", "const_cast", "continue", "default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern", "false", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable", "namespace", "new", "operator", "private", "protected", "public", "register", "register_cast", "return", "short", "signed", "sizeof", "static", "static_cast", "struct", "switch", "template", "this", "throw", "true", "try", "typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void", "wchar_t", "volatile", "while"&#125;;//动态数组vector&lt;string&gt; reserveWordVector(reserveWord, reserveWord + RESERVEWORDNUM);//检测是否是保留字bool isReserveWord(string &amp;word)&#123; vector&lt;string&gt;::iterator itV; itV = find(reserveWordVector.begin(), reserveWordVector.end(), word); if ( itV != reserveWordVector.end() )&#123; return true ; &#125; else &#123; return false ; &#125;&#125;void translate(string filename)&#123; ifstream infile; //输入流对象 infile.open(filename + ".cpp"); ofstream outfile; //输出流对象 outfile.open(filename + ".html"); int line = 0; //记录cpp文件行数 if (!infile &amp;&amp; !outfile)&#123; cout &lt;&lt; "ERROR：打开文件失败！" &lt;&lt; endl; return ; &#125; string aLine; //存放cpp文件一行代码 string::iterator lineIte; //定义行迭代器 //读取一行代码 while (getline(infile, aLine)) &#123; line++; //更新行数 aLine += " "; //每行后添加空白防止迭代器溢出 string aHtmlLine = ""; //html的一行 lineIte = aLine.begin(); //初始化行迭代器指向行首位置 //对该行进行分割，对分割出的字进行检测 while (lineIte != aLine.end())&#123; string word = ""; //存放一个单词 //行迭代器遇到空格或换行符号时停止并截取单词 while (*lineIte != ' ' &amp;&amp; *lineIte != aLine.back())&#123; //针对html语法，对字符串的处理 if (*lineIte == '&lt;') &#123; word += "&amp;lt;"; &#125; else if (*lineIte == '&gt;') &#123; word += "&amp;gt;"; &#125; else if (*lineIte == '&amp;') &#123; word += "&amp;amp;"; &#125; else if (*lineIte == '\"') &#123; word += "&amp;quot;"; &#125; else if (*lineIte == '\t') &#123; aHtmlLine += " &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "; &#125; //处理缩进问题 else &#123; word += *lineIte; &#125; lineIte++; &#125; //检测单行注释 if (*word.begin() == '/' &amp;&amp; *(word.begin() + 1) == '/') &#123; word = "&lt;font color=\"yellow\"&gt;&lt;b&gt;" + word + "&lt;/b&gt;&lt;/font&gt;"; //注释为黄色 &#125; //检测多行注释 if (*word.begin() == '/' &amp;&amp; *(word.begin() + 1) == '*') &#123; word = "&lt;font color=\"yellow\"&gt;&lt;b&gt;" + word ; //注释为黄色 &#125; if (*word.rbegin() == '/' &amp;&amp; *(word.rbegin() + 1) == '*') &#123; word = word + "&lt;/b&gt;&lt;/font&gt;"; &#125; //检测是否是保留字 if (isReserveWord(word)) &#123; aHtmlLine += "&lt;font color=\"blue\"&gt;&lt;b&gt;" + word + "&lt;/b&gt;&lt;/font&gt;"; //加粗保留字并设置为蓝色 &#125; else &#123; aHtmlLine += word; //其他字不做处理 &#125; if (*lineIte == ' ') &#123; lineIte++; aHtmlLine += " "; &#125; &#125; //检测是否是头文件行 if (*aLine.begin() == '#') &#123; aHtmlLine = "&lt;font color=\"green\"&gt;&lt;b&gt;" + aHtmlLine + "&lt;/b&gt;&lt;/font&gt;"; //头文件行变绿色 &#125; outfile &lt;&lt; "&lt;font color=\"black\"&gt;&lt;b&gt;" &lt;&lt; setw(4) &lt;&lt; setfill('0') &lt;&lt; line &lt;&lt; "&lt;/b&gt;&lt;/font&gt;&amp;sdot; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;" + aHtmlLine + "&lt;br/&gt;" &lt;&lt; endl; //写入.html文件 &#125; infile.close(); //关闭文件流 outfile.close(); //关闭文件流 cout &lt;&lt; "转换成功！" &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; "请输入您要转换的cpp文件："; string cppFileName; cin &gt;&gt; cppFileName; translate(cppFileName); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扔鸡蛋问题]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Google有一道扔鸡蛋的面试题目： You work in a 100 floor building and you get 2 identical eggs.You need to figure out the highest floor an egg can be dropped without breaking.The question is how many throws you need to make.Find an algorithm that is minimizing number of throws in the worst-case scenario. 这道题的意思大致如下： 情景假设1、你在一个 100层高的大楼里； 2、你有 2个一模一样的鸡蛋； 任务1、弄清楚： 鸡蛋最高可以从几层楼扔下去而不会被摔坏； 2、弄清楚你需要扔几次； 3、 提出一个算法，找出在最坏情况下，扔出鸡蛋而不把鸡蛋摔坏的最少次数； 假设首先，在解题之前，我们要做好几个简单的假设： 2个鸡蛋的脆弱程度是一样的。 如果鸡蛋从N楼扔下来没有碎，那么它从小于N楼扔下来，也不会碎 如果鸡蛋从N楼扔下来碎了，那么它从大于N楼扔下来，也一定会碎 一颗扔出去但没有碎的鸡蛋，可以继续被用于试验。 碎了的鸡蛋将无法再继续试验。 有了这些假设之后，我们就可以解题了。 其实解决这道问题的方法有很多，在此列举一些： 最简单解法最简单的一个方法，就是 将鸡蛋从第一层开始，逐层扔出，看它在哪一层会摔碎。 这个方法虽然可靠，但它可能需要进行很多次尝试。比如，在最差的情况下，它需要尝试的次数是100次。 需要注意的一点是，当你只有一颗鸡蛋时，这个算法是唯一可靠的方法。 所以一旦你打碎了第一颗鸡蛋，手里只剩下最后一颗的时候，你就要开始运用这个算法。 最直观解法这个方法重点，是要 利用好第一颗鸡蛋，最大效率地把100层高楼划分成N个更小数目的区间。 一个比较直观和流行的答案是， 将鸡蛋从【要检查的楼层* 1/N】层开始扔下去，逐层检查。 例如，当N=3时，我们就将第一颗鸡蛋从100*1/3 ≈ 33层楼扔出： ► 如果它破损了，我们就接着用第二颗鸡蛋检验32层楼及以下。 ► 如果它没破损，我们就继续将同一颗鸡蛋从33 + (67 * 1/3) = 55层楼扔出，如果它破了，我们就用第二颗鸡蛋，检验34层 - 55层 …… 当N = 3时，最坏的情况是max(33, 24, …) = 33层。 按照这个思路，再通过dynamic programming，我们就可以找到一个完美的N，来最优化鸡蛋的投掷次数了。 这个解法在面试中还是很有&quot;价值&quot;的，毕竟它能向面试官展现求职者的编程思维。但它还不是最佳解法。 最优解在理解最佳解法之前，我们需要理解以下这个equilibrium（均衡状态）： 这个均衡状态计算的是在最坏情境下，所需的扔鸡蛋次数。这里，F(n)指的是楼层，是我们扔第一个鸡蛋后的下一层。 假如我们引入以下变量： 那么刚刚的equilibrium就变成这样： 当这个函数里的所有参数都相等时，就是我们的最优解。 那么我们如何做到呢？ 从末尾开始看，最后的D(n)将会变成1，因为最终我们将会到达一个点 —— 就是只剩下一层楼可以扔第一颗鸡蛋。 因此，D(n-1)应该等于2。 我们接着会发现，第一颗鸡蛋最终应该是从第99层楼扔出，之前是从99-2=97层，再往前则是97-3=94层，90, 85, 79, 72, 64, 55, 45, 34, 22，然后是第9层。 这就是一个最优解！ 这样一来，我们就得出了答案： 在最坏的情况下，我们需要的扔鸡蛋的最少次数，是14次 （最小的差别在于13，但是我们还需要在第9层额外扔一次）。 检查现在就到了检验我们的解法是否正确的时候了。我们可以编写一个简单的Kotlin程序来检验答案。首先，我们需要解释一下，如何在某些决策中，计算扔鸡蛋次数。当有2层或更少的楼层时，我们需要按照剩余的楼层数，来决定扔鸡蛋的次数。 否则，我们应该调用以下均衡函数： 我们在这里使用了bestMaxThrows函数。这是一个假设的函数，它会返回一个投掷次数的数值，并假设接下来的一系列决策是完美的。 我们是这样定义它的： 同样，我们把&quot;计算下一层最优解&quot;的任务，交给了bestNextStep 函数。这个函数很好的为我们指明了下一步的方向。我们可以这样简单地定义它：当只有二层或更少的楼层待检验时，我们会从第一层扔出鸡蛋。否则，我们需要检查所有备选项，然后找到最优解。 下面是具体执行步骤： 需要注意的是，这个方程用了maxThrows函数，因此会涉及到recurrence （循环）。 但这并不成问题，因为当bestNextStep调用maxThrows时，它始终会使用比floorLeft更小的值调用它（因为nextFloor总是大于0）。 在我们使用它之前，我们需要添加一些缓冲，从而加速计算： 首先，我们可以检查它是否返回与我们计算结果相同的结果： 结果是14 —— 这个结果看上去还不错，我们接着检查之后的几个步骤： Result9, 22, 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, 100, 跟我们计算的结果是一致的! Bigger picture以上分享的这个算法，其实还可以解决许多其他类似的问题。 比如，我们可以把原题的提问改改，改成计算最随机情况下的扔鸡蛋次数。我们还可以看看，当建筑物的高度有变化时，得出的结果是否也会跟着变化。 下图很好地回答了以上问题：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2018%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;2018年2月26日，基于Hexo框架并由GitHub提供服务器，我建立了第一个自己的博客网站 (https://conglindev.github.io/)&ensp;&ensp;&ensp;&ensp;虽然功能不完善，但是具有了博客的基本的功能。以后我会尽量完善和美化这个网站的。 Hello world!]]></content>
  </entry>
</search>
